<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[通过发币学习以太坊智能合约]]></title>
    <url>%2F2018%2F07%2F30%2F%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B9%8B%E5%8F%91%E5%B8%81%2F</url>
    <content type="text"><![CDATA[点进来我就把你当成一个会写代码，玩过 ICO 的人，ICO 通过发币融资的方式分分钟走向人生巅峰，迎娶白富美，那么到底是如何发币，发币难不难，我们只知道炒币，不知道发币，那你怎么敢买的？ 一个简单的 token 合约包括：代码部署，转账，上传代码到etherscan并验证，代币管理，代币增发，冻结，销毁，到我们熟知的 ICO。 开发环境，在线IDEremix 首先来看一下最简单并且可以转账的代币长什么样： 123456789101112131415161718pragma solidity ^0.4.24;contract SimpleToken &#123; mapping(address =&gt; uint256) public balanceOf; constructor (uint256 init) public&#123; balanceOf[msg.sender] = init; &#125; function transfer(address _to, uint256 _value) public&#123; //防溢出 require(balanceOf[msg.sender] &gt;= _value); require(balanceOf[_to] + _value &gt;= balanceOf[_to]); balanceOf[msg.sender] -= _value; balanceOf[_to] += _value; &#125;&#125; 那我们去 etherscan 上看一下，正经的代币长什么样子，都包含哪些东西。 以 BNB 为例，有 name，totalSupply，decimals，balanceOf，owner，symbol，freezeOf，allowance。 其中name，totalSupply，decimals，symbol 是ERC20标准代币规范，每个代币都必须要有的。 12345678910111213141516171819contract erc20Interface&#123; string public name; string public symbol; uint8 public decimal; uint public totalSupply; function transfer(address _to,uint256 _value) public returns (bool succ); function transferFrom(address _from,address _to,uint256 _value) public returns (bool succ); function approve(address _spender,uint256 _value) public returns (bool succ); function allowance(address _owner,address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from,address indexed _to,uint256 _value); event Approve(address indexed _owner,address indexed _spender,uint256 _value); &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455pragma solidity ^0.4.24;import &apos;./erc20Interface.sol&apos;;contract ERC20 is erc20Interface&#123; mapping(address =&gt; uint256) balanceOf; mapping(address =&gt; mapping(address =&gt; uint256)) allowed; constructor(string _name,string _symbol,uint8 _dec,uint _total) public&#123; name = _name; symbol = _symbol; decimal = _dec; totalSupply = _total; balanceOf[msg.sender] = totalSupply; &#125; function transfer(address _to,uint256 _value) public returns (bool succ)&#123; require(_to != address(0)); require(balanceOf[msg.sender] &gt;= _value); require(balanceOf[_to]+_value &gt; balanceOf[_to]); balanceOf[msg.sender] -= _value; balanceOf[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; &#125; function transferFrom(address _from,address _to,uint256 _value) public returns (bool succ)&#123; require(_to != address(0)); require(allowed[_from][msg.sender] &gt;= _value); require(balanceOf[_from] &gt;= _value); require(balanceOf[_to]+_value &gt; balanceOf[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; allowed[_from][msg.sender] -= _value; emit Transfer(msg.sender, _to, _value); return true; &#125; function approve(address _spender,uint256 _value) public returns (bool succ)&#123; allowed[msg.sender][_spender] = _value; emit Approve(msg.sender,_spender,_value); return true; &#125; function allowance(address _owner,address _spender) public view returns (uint256 remaining)&#123; return allowed[_owner][_spender]; &#125;&#125; 所有的 erc20 继承erc20Interface接口，代币规范中的几个在创建的时候就要实例化完成，所以我们写一个构造函数constructor声明，从外面传过来。实现接口中的方法，transfer就是一个发送地址做减法，接收地址做加法的过程。require检查各种异常情况，包括溢出，接收地址是不是无效之类的。如果失败，则会被 revert 掉。反之用emit触发事件。 我们在 log 中可以看到，emit 触发的事情返回长这个样子 12345678910111213&quot;from&quot;: &quot;0x5e72914535f202659083db3a02c984188fa26e9f&quot;, &quot;topic&quot;: &quot;0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef&quot;, &quot;event&quot;: &quot;Transfer&quot;, &quot;args&quot;: &#123; &quot;0&quot;: &quot;0x0000000000000000000000000000000000000000&quot;, &quot;1&quot;: &quot;0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c&quot;, &quot;2&quot;: &quot;1000&quot;, &quot;_from&quot;: &quot;0x0000000000000000000000000000000000000000&quot;, &quot;_to&quot;: &quot;0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c&quot;, &quot;_value&quot;: &quot;1000&quot;, &quot;length&quot;: 3 &#125;&#125; 部署下面我们将 erc20部署到测试网络，remix 小狐狸插件metamask,将合约代码部署到测试网络。metamask 安装使用方法自行Google。我们将 remix 右边栏 run 选项中的Environment切换成Injected Web3，每次执行 deploy 的时候都会启动狐狸插件，第一次安装是没有 eth 的，小狐狸会提示你 BUY，去测试水龙头自行购买，速度取决于测试环境 eth网络。购买成功，我们将 gas 调大一点，部署合约速度会更快。平时我们自行测试用JSVM 环境就好了，调试都一样，唯一不一样的就是是否上链。部署合约，触发函数都会消耗 gas。 当我们合约部署成功之后 https://ropsten.etherscan.io/token/你的地址，这个地址就是 remix 中deploy 时合约名字后面的地址，直接访问可以看到当时你设置的名字之类的，在readContract这个 tab 下面会让你 please Verify Your Contract Source Code here.验证代码，那我们就把代码拷贝进去然后，合约名字，编译环境都要和我们部署的时候一致，不要搞错了，点击验证并发布，不出意外等一会成功，然后我们就看到了我们刚开始 BNB 页面一样的效果了。 增发：主要两步代币的管理者 Owner，然后修改我们的totalSupply总量。这里我们会用到一个函数修改器modifier，先看代码 1234567891011121314151617pragma solidity ^0.4.20;contract Owned &#123; address public owner; constructor () public&#123; owner = msg.sender; &#125; modifier onlyOwner&#123; require(msg.sender == owner); _; &#125; function transferOwnerShip(address newOwner) public onlyOwner &#123; owner = newOwner; &#125;&#125; 上面的代码等价于 1234567891011121314pragma solidity ^0.4.20;contract Owned &#123; address public owner; constructor () public&#123; owner = msg.sender; &#125; function transferOwnerShip(address newOwner) public &#123; require(msg.sender == owner); owner = newOwner; &#125;&#125; 一下子就看懂了吧。 我们想要的效果就是只有owner才可以执行transferOwnerShip，其他地址用户访问会被拒绝。owner 就是我们部署合约的主账号。 代币管理者 owner 已实现，下面我们来修改totalSupply。 12345678910111213141516171819202122pragma solidity ^0.4.20;import &quot;./erc20.sol&quot;;import &quot;./owned.sol&quot;;contract AdvanceToken is ERC20,Owned &#123; event AddSupply(uint amount); constructor (string _name,string _symbol,uint8 _dec,uint _total) ERC20(_name,_symbol,_dec,_total) public &#123; &#125; function mine(address _target,uint _amount) public onlyOwner&#123; totalSupply += _amount; balanceOf[_target] += _amount; emit AddSupply(_amount); emit Transfer(0,_target,_amount); &#125;&#125; 实现代币冻结资产在钱包但是不能交易。 1234567mapping(address =&gt; bool) public frozenAccount;event FrozenFunds(address _target,bool frozen);//资产冻结function freezeAccount(address _target,bool freeze) public onlyOwner&#123; frozenAccount[_target] = freeze; emit FrozenFunds(_target,freeze);&#125; 上面已讲资产冻结但是还可以交易，下面我们对交易函数做一下判断。 12345678910111213141516171819202122232425function transfer(address _to,uint256 _value) public returns (bool succ)&#123; succ = _transfer(msg.sender,_to,_value);&#125;function transferFrom(address _from,address _to,uint256 _value) public returns (bool succ)&#123; require(allowed[_from][msg.sender] &gt;= _value); succ = _transfer(_from,_to,_value); allowed[_from][msg.sender] -= _value;&#125;function _transfer(address _from,address _to,uint256 _value) internal returns (bool succ)&#123; require(_to != address(0)); require(!frozenAccount[_from]); require(balanceOf[_from] &gt;= _value); require(balanceOf[_to]+_value &gt; balanceOf[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); return true;&#125; 代币冻结并不能交易也 OK 了。下面来实现代币销毁。 代币销毁账户金额减少，总发行量减少，两个功能。 1234567891011121314151617181920212223242526event Burn(address _target,uint amount);//资产销毁function burn(uint256 _value) public returns (bool success)&#123; require(balanceOf[msg.sender] &gt; _value); totalSupply -= _value; balanceOf[msg.sender] -= _value; emit Burn(msg.sender,_value); return true;&#125;function burnFrom(address _from,uint256 _value) public returns (bool success)&#123; require(balanceOf[_from] &gt;= _value); require(allowed[_from][msg.sender] &gt;= _value); totalSupply -= _value; balanceOf[_from] -= _value; allowed[_from][msg.sender] -= _value; emit Burn(_from,_value); return true;&#125; 上面我们讲过冻结，他是冻结某个账号所有token。现在市面上很多 ICO 都是token 锁定并分批释放解锁。 分批释放解锁同样我们可以用 mapping 来保存账号锁定的token，我们在 transfer 的时候对锁定的token进行判断然后转账，我们还要考虑到分批解锁，与时间相关，随着时间的推移，锁定的token会越来越少。 ICO一 ：包括众筹时间，目标，兑换价格，受益人几个参数。二 ：实现代币与以太币的兑换。三：众筹成功下发 token，失败退款相应 eth 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081pragma solidity ^0.4.20;import &apos;./Owned.sol&apos;;interface token &#123; function transfer(address _to,uint _amount) external;&#125;contract ico is Owned&#123; uint public fundingGoal; uint public deadline; //截止日期 uint public price; uint public fundAmount; token public tokenReward; address public beneiciary;//受益人 mapping (address =&gt; uint) public balanceOf; event FundTranfer(address backer,uint amount); event FundReached(bool sucess); constructor (uint fundingGoalInEther,uint durationInMinu,uint etherCostofEachToken,address addressOfToken) public&#123; fundingGoal = fundingGoalInEther * 1 ether; deadline = now + durationInMinu * 1 minutes; price = etherCostofEachToken * 1 ether; //1eth = 10 ** 18 wei tokenReward = token(addressOfToken); beneiciary = msg.sender; &#125; function () public payable&#123; require (now &lt; deadline); uint amount = msg.value; //wei balanceOf[msg.sender] += amount; fundAmount += amount; uint tokenAmount = 0; //实现空投 if (amount == 0)&#123; tokenAmount = 10; &#125;else&#123; tokenAmount = amount / price; &#125; tokenReward.transfer(msg.sender,tokenAmount); emit FundTranfer(msg.sender,amount); &#125; //只有 owner 才可以设置阶梯价格 function setPrice(uint etherCostofEachToken) public onlyOwner&#123; price = etherCostofEachToken * 1 ether; //1eth = 10 ** 18 wei &#125; //检查众筹是否结束 modifier afterDeadLine&#123; require(now&gt;=deadline); _; &#125; function checkFundReachd() public afterDeadLine&#123; if(fundAmount &gt; fundingGoal)&#123; emit FundReached(true); &#125; &#125; function withdrawal() public afterDeadLine&#123; if(fundAmount &gt; fundingGoal)&#123; //众筹成功 if(beneiciary == msg.sender)&#123; beneiciary.transfer(fundAmount); &#125; &#125;else&#123; uint amount = balanceOf[msg.sender]; if(amount &gt; 0)&#123; msg.sender.transfer(amount); msg.sender = 0; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序初探]]></title>
    <url>%2F2016%2F12%2F04%2Fxiaochengxu%2F</url>
    <content type="text"><![CDATA[最近很是火热的莫过于小程序了,我也来凑凑热闹,体验了一把,关于小程序的定义,网上流传的张小龙朋友圈是这样说的: 小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载 官网必须有 Demo Gif 主要实现了一个记事本的小demo, 可以增加,可以修改,简单记录一下,学习一下而已.大致目录如下: 其中 .js,.wxml,.wxss,.json分别对应的是我们逻辑,布局,样式,后面那个我们可写可不写,很清晰,相当于我们 Android 上面的 java 代码, xml 布局, style 样式差不多.一些组件,一些框架官网已经很全了,还给了栗子,直接拿来改改就可以用!例子中并没有申请开发者,只是简单的注册了开发者,所以拿到了 appId, 可以真机测试,这点比较爽,不能上架而已!上架这些事如果不真心的话,还是看公司发展吧!里面一些申请的过程比较公司化,所以不怎么会搞!!里面的数据存储由于没有后台支持,只能使用它们自己的 storage,最大支持10M, 应该够了!后面会把代码放到 github 的! 最后来看看爱范儿的一篇文章吧 微信小程序的想象力与不可想象域 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity 和 Fragment 生命周期对比]]></title>
    <url>%2F2016%2F06%2F27%2Factivity-fragment-lifecycle%2F</url>
    <content type="text"><![CDATA[正好推荐一款画流程图的利器,chrome 插件 gliffy-diagrams 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Activity Fragment生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio-NDK初探]]></title>
    <url>%2F2016%2F06%2F20%2FandroidStuio-ndk-demo%2F</url>
    <content type="text"><![CDATA[话说 AndroidStudio从面世以来就一直被质疑能不能用这玩意开发NDK哪,从1.3以后貌似就支持的差不多了,现在都2.2了我才用他来玩NDK, 真是惭愧啊,鼓捣了一下午,看了几篇博客,想到了高中生物课本的一句话,”一猪生九仔,连母十个样啊!!”既然AndroidStudio已经这么人性化了,看了几个决定自己点点看,但是一些地方还是要谢谢那几篇博客啦! ndk 环境配置搭建配置ndk 到我们的环境变量中去,和当初我们配置adb是一样的,打开我们的.bash_profile文件(Windows 请自行Google),把我们的 ndk 路径放进去,话说现在AndroidStudio已经很完美的支持ndk了,ndk的下载可以像下载sdk那样下载了,下载完你的目录会多出一个ndk-bundle目录,那就是我们需要关心并把他的路径放到bash_profile文件中去的.使其bash_profile文件生效,并在终端输入ndk-build,如果有信息输出并不是error级别的那就证明 ok 了. 新建 ndk 项目我们用 AndroidStudio(2.1.2) 新建我们的 ndk 项目,和 Android 项目一样,这里我打算用 ndk写一个求和的 demo,MainActivity就是一个 TextView 显示我们的求和结果,没有说的,然后我们新建一个 Java 类,用来实现native方法 1234567public class NDKTest&amp;#123;public static native int add(int a,int b)&amp;#123; static&amp;#123; System.loadLibary("NDKDEMO"); &amp;#125; &amp;#125;&amp;#125; 这里暂时用到这两个文件,如何才能发挥他们的威力,下面会讲.那么这里面有这么一行System.loadLibrary(&quot;NDKDEMO&quot;);,那我们就要开始配置我们的 ndk 到项目使其生效,首先打开local.properties这个文件,把 ndk 的路径像 sdk 那样配置进去,然后在gradle.properties这个文件尾加上android.useDeprecatedNdk=true,最后在 app gradle 文件中加上 123ndk&amp;#123; moudleName "NDKDEMO"&amp;#125; 看出来了吧,上面的System.loadLibrary其实就是这地方的moduleName,同步我们的工程,应该不会报错! jni 的两种生成姿势AndroidStudio的智能体现我们在 MyNDK 中定义了一个 native 方法,但是他报红了,我们使用 AndroidStudio 的智能提示, alt+enter, 看到第一个选项就是然后我们看到 main 下面多出了一个 jni 目录,下面多出了和moduleName一样的文件,打开我们可以看到 12345#include &lt;jni.h&gt;JNIEXPORT jint JNICALLJava_ndktst_android_com_ndkdemo_NDKTest_add(JNIEnv *env,jclass type,jint a,jint b)&amp;#123; return a+b;&amp;#125; 形式就是包名+ native类名+方法名,这样就OK, 我们把 a+b 返回,然后我们在 MainActivity 中 12NDKTest myNdk = new NDKTest();textView.setText(myNdk.add(1,1)+""); 这样 TextView 中显示2,成功. 最装逼也是最常用的姿势这一种是我们最常用的姿势,在 AndroidStudio 中打开终端,定位到我们的 Java 目录,输入javah -jni packageName+className去我们的 jni 目录看见生成了一个很长的.h 文件,以本例为例,生成了一个这东西ndktst_android_com_ndkdemo_NDKTest.h,一般不在这个文件中进行操作,会在复制一个文件,命名为.cpp的文件, 123456#include "ndktst_android_com_ndkdemo_MyNDK.h"#include "Add.h"jint Java_ndktst_android_com_ndkdemo_NDKTest_add(JNIEnv *env,jclass jclassl,jint jint1,jint jint2)&amp;#123; Add add; return add.addFromClass(jint1.jint2);&amp;#125; 然后我们新建一个C++类,自动生成. h 和. cpp的文件,.h 文件中我们这样写 1234567#ifndef NDKDEMO_ADD_H#define NDKDEMO_ADD_Hclass Add&amp;&amp;#123; public: int addFromClass(int a,int b);&amp;#125;#endif //NDKDEMO_ADD_H .cpp 这样写 1234#include "Add.h"int Add::addFromClass(int a,int b)&amp;#123; return a+b;&amp;#125; 上面那个很长的. cpp 文件应该找到解释了吧,我们只不过是把加法运算的方法重新定义了类,在那里面调用.最后运行的结果是一样的!!! 大功告成这里我们只是传递了 int 类型的,那么我们在实际开发中用到的不止 int 类型,可能我们要传一个对象等等啊,就完全不一样了,我们要去看官方文档,有点复杂,这篇文章只是和大家一起在 AndroidStudio 上面先把 ndk 玩转而已!!!真实开发中用到的时候再来填坑吧!!!!一个好朋友献上的,😄😄 NDK 指南developers.google.ndk 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>AndroidStudio</category>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>AndroidStudio</tag>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App后台开发运维和架构实践Reading Notes 1]]></title>
    <url>%2F2016%2F06%2F18%2FappSecurityStudy%2F</url>
    <content type="text"><![CDATA[App后台开发运维和架构实践读书笔记(1)第三章 App 后台核心技术.可能有人看到这会说为什么会从第三章开始讲,因为前两章讲的 App 后台入门,后台基础技术,也可以去下载试看前三章,既然可以试看前三章,那为什么还写第三章,因为第三章太值得我们去看去写了,虽然还没看完,就想停下来动笔去写写这样忘得才能慢一点.待续—– /usr/local/Cellar/python3/3.4.3_1/Frameworks/Python.framework/Versions/3.4 目录1App后台开发运维和架构实践 目录2App后台开发运维和架构实践 作者 CSDNApp后台开发运维和架构实践购买地址 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
        <category>后台</category>
      </categories>
      <tags>
        <tag>App 后台开发运维和架构实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle多版本差异化管理]]></title>
    <url>%2F2016%2F05%2F25%2Fgradle-diff-flavors%2F</url>
    <content type="text"><![CDATA[今天我们来说一说Gradle多版本差异化管理，在实际开发中我们往往经常需要打不同的APK来满足我们不同需求。不用手动改来改去一些多余的需求，用我们AS+Gradle就可以完美解决。废话不多说，开车。 先看图，我们通过切换不同的Build Variant，生成我们需要的APK 下面我们来看看在AS中我们要如何展开这项工作的，在我们app的gradle配置中我们只需要这么做，首先我们要明确两个概念 buildTypes可以为不同的用户、不同的渠道打包不同的apk包，以便在程序行为上针对不同使用需求做少量定制（如是否可以更改远程服务器地址等) productFlavorsproductFlavors主要针对于”不同的版本之间差异非常小，本质上是同一应用”这种情况。可以根据渠道不同在版本名中增加相应后缀，可以根据特殊客户要求打包不同 ApplicationID 的apk包，并可分别使用不同的资源文件（如不同的应用图标等） 12345678910defaultConfig &amp;#123; applicationId "android.com.test" &amp;#125;productFlavors &amp;#123; pro &amp;#123; applicationId "android.com.test.pro" &amp;#125; free &amp;#123; &amp;#125;&amp;#125; 这里可以看到我们加了productFlavors，里面一个pro版，一个free版，我们为高级版的定了不同的applicationId，而普通版的就是使用我们默认的applicationId，gradle中简单配置就先这样了。然后我们需要在src目录下面新建我们刚刚加的两个渠道 快速生成我们的java，res目录，新建一个空Activity就好了，然后在里面植入我们需要的代码，下面贴上代码。 这里我在pro，free文件中各自新建了一个自定义的MyView，里面代码很简单 free: 123456public MyView(Context context)&amp;#123; super(context); LayoutInflater inflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); View inflate = inflater.inflate(R.layout.free, null); setContentView(inflate); &amp;#125; pro: 123456public MyView(Context context) &amp;#123;super(context);LayoutInflater inflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);View inflate = inflater.inflate(R.layout.pro, null);setContentView(inflate);&amp;#125; 然后我们就可以在main文件中的Activity去调用他们了。 1234567viewById.setOnClickListener(new View.OnClickListener() &amp;#123;@Overridepublic void onClick(View v) &amp;#123;MyView myView = new MyView(Activity.this);myView.show();&amp;#125;&amp;#125;); 这里自定义的一个dialog，你自定义啥都行，你也可以写Activity，然后main里面跳转，都是可以的。如果想把pro的apk名字改一下也和简单，正常处理就好了，在strings.xml目录中加入app_name就好了，然后下面到了最后一步 可以看到这里有四个版本，分别对应我们设置的debug，release版本，选择运行，这样就可以在手机上面显示我们自己的两个apk了!!! 这里需要注意的是我们新建flavors文件要看好了，注意它们的依赖关系，我们新建的布局文件记得依赖当前文件，不是依赖main文件哦。不然会出问题的！ 参考文章利用 Android Studio 和 Gradle 打包多版本APK 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>AndroidStudio</category>
      </categories>
      <tags>
        <tag>AndroidStudio</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac上的一些高效而又不为人知的小工具]]></title>
    <url>%2F2016%2F05%2F11%2Fmac-efficient-tools%2F</url>
    <content type="text"><![CDATA[网上也有很多的介绍如何玩转你的Mac，For example程序员如何优雅地使用 Mac？知乎的这一篇就很不错，当然还有很多，但是今天我还要去写，写我自己一直在用的，而且用的很给力的一些小工具介绍给大家。 用Mac也快一年了，先晒一下我一直在用的一些(多图预警，请注意) 当然还有一些例如QQ，微信，邮箱等啊，这些基本属于必备用品了，这里不多说，上面晒出的5张图是我的5个分类，大家可能也能看出来，这里捡一些好玩而且经常用到的Application来一起看看。 Drop to Gif 见名知意，就是将我们平时的一些小视频转成GIF的一个小工具。附上他的一个使用效果 CheatSheet CheatSheet 做的事情很简单，就是在你使用任何软件的时候，长按Command键，即可显示当前软件的所有快捷键。通过这个提示功能，便能快速地找到你想要的快捷键.下面是在Android Studio上面的使用情景 Sip 之前推荐的ColorPicker，但是最近却在App Store上面发现了一个更给力的吸色工具，那就是Sip，具体可以去App Store上面看，强大啊 licecap Mac上面小巧的GIF格式录屏App，用户可以自定帧率和录制范围 Alfred2 可以替代Mac本家的Spotlight搜索的一款自定义的搜索App，这是一款收费软件，如果想玩workflow就要付费了。。。。使用的话看他就够了借助 Alfred 2 的 Workflows 功能可以做哪些好玩的事情？小白使用 SmartFinder 一款Mac与Android机无缝连接的App，方便自如地管理您在 Android 手机中的内容，锤子出品！ Snip 一款简单的截图工具，可以滚动截屏 MacID 可以根据手机的蓝牙信号强度（设备间距离越大信号越弱）来控制是否自动解锁或者锁定 Mac。新版本的 MacID 还支持在设备间传递剪贴板内容，感觉又可以少装一个剪贴板传递的应用。教程 Mark Man 一款设计稿标注，测量工具。极大节省设计师在设计稿上添加和修改标注的时间，让设计更有爱哦 Mounty 安装brew cask install mounty，Mounty 这个小软件虽然小但是功能挺实用的. 当你插入 NTFS 硬盘后会提示是否创新加载成读写模式. 尤其是写入模式很重要. 因为 Mac OS X 默认没有开启 NTFS 的写入模式. 这样不在需要安装其他软件就可以对 Windows 的 NTFS 硬盘进行复制文件操作啦.当有硬盘接入的时候会显示是否装载成写入模式 , 点击 YES 即可. Manico 是一个为 OS X 设计的快速的 App 启动和切换工具，网站上面说的很清楚了已经这里就不阐述了。 iSart Menus Dr Cleaner 一款OSX App，清理磁盘和内存，应用程序卸载，系统优化，App Store上面即可下载，今天刚更新的，已经集成了iStart Menus的功能，所以上面的就没介绍了。 The Unarchiver 一款小巧的解压缩App，可以使用它解压多达30种不同的压缩格式文件 ShowOrHide 简单的替换了命令行，可查看隐藏文件的一个小巧的App，简单的不要不要的 AndroidTool 代替了你的adb install xx.apk，点击apk就可安装到你手机的一个玩意。还可以对你的手机进行录屏操作，可以去官网查看 Karabiner 这是一个自定义键盘的一个小软件，用外接机械键盘的小伙伴可以用到这玩意哦。 teamViewer 远程协作的一个在线会议软件。 Subler 是一个讲视频和字幕合成一体的一个软件。我们有时候看美剧可能没有字幕，但是我们又下载了字幕，还要导入或者一些什么，但是有了这个东西就方便了，我们直接合成就好了。最后file－save LastPass Mac上面的密码管理工具，需要付费，LastPass帮助文档,入门够了help文档 HBuilder 一款HTML5 IDE，超爽 Charles Mac 下常用的网络封包截取工具，付费软件，但是好用的不得了。想驾驭它，看他就够了Charles 从入门到精通 iTerm 之前有一篇文章介绍过它iTerm新手必知还有一篇文章也不错iTerm配置 MWeb 付费买的一个markDown编辑器，Mou，markdown也有用过，感觉总是少点什么，但是用了它之后就想过换啊，去官网看他的牛逼功能介绍吧。有付费版，免费版，如果对他要求不高的话，免费足够用了！！ SourceTree 如果你对git命令用的不6，那么就来用它吧，英文，中文，都有，免费，功能强大，这些能吸引你吗？ Sublim Text3 代码编辑器或者文本编辑器，跨平台支持Win/Mac/Linux，支持32与64位，支持各种流行编程语言的语法高亮、代码补全等如何优雅的使用SublimeText3 WebStormEAP PHPStormEAP webstorm过人之处用法自行搜索就好了。 上面这两款软件都是出自一家，但是要付费，你可以付费，但是挺贵，你可以去找一些破解版的，一个注册码，但是用着感觉不舒服，上面给出的均是EAP版，不用付费，不用破解，功能几乎完全够你用的啦。 MindNote 头脑风暴思维导图软件 Dash App Store上面即可下载，程序员的好帮手，强悍的API文档浏览，搜索功能 Hopper 一款反汇编工具：Hopper，它有OS X和Linux版本，能够反汇编32/64位Mac，Linux，Windows和iOS可执行文件。Hopper工具使用将我们的可执行文件拖进去即可。 WeiboX 微博的Mac客户端，不介绍 Moviest Mac上面的一个第三方视频播放软件，App Store可下载。 下面这些参考stormzhang的来看比较好私人珍藏的Chrome插件,吐血推荐 Chrome ADB Vysor Postman pocket momentum YouTube Gliffy Diagrams 介绍一下最后一个，一个专业的流程图软件 以上这些去Chrome网上商店均可下载。 Evernote 印象笔记，用这个可以将我们在chrome上浏览好的内容保存在我们印象笔记中，去下载插件就好了 还有一个给力的地方就是我们用微信关注他的官方公众号，然后将我们在公众号上面看到的好文章保存到我们的印象笔记中，岂不是极好极好的。 PDF Reader PDF阅读软件，App Store即可下载。 奇妙清单 计划你的一些日程，随时收到提醒，跨平台让你的生活保持同步。 这里还有一些Chrome的插件介绍， 一个广告屏蔽插件 见名知意 下两个见stormzhang博客 妈妈再也不用担心我的macbook发烫了 一个很好用的博客图片链接生成插件(微博图床) Mac上面一款万年历 怎么样，还可以吧 XtraFinder多样化你的Finder 可以像chrome浏览器一样，tab多开，可以拷贝路径，可以右键新建文件，文件夹…..反正事中文版的，去设置里面看一下，就知道有没有你想要的啦！！ 还有就是百度云盘在Mac上面基本是难用到恶心啊，这里之前我也说过可以有一个插件帮我们搞定这恶心的事情百度云盘在Mac上的威力 还有一些Mac本身的小技巧你可能不知道的小技巧Mac上面用机械键盘的壕友们这里也有你们的福利OS X下机械键盘的设置和技巧（不仅仅是改苹果键）OSX 下一些冷门但是一旦发现就无法自拔的软件谢谢你在这多图预警下看到这里了，这里面肯定有你用到的也有你没有用到的，哪怕只有一个能帮助你，也值了啊！ 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Mac小工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白学Android之adb篇(三)]]></title>
    <url>%2F2016%2F04%2F18%2Fadb-study-03%2F</url>
    <content type="text"><![CDATA[我们之前一起看了adb和adb logcat的一些简单命令，今天我们在一起来看看adb还有什么好玩的值得我们说的。如何通过adb命令来安装一个App和卸载一个App，简单的命令就可以简化我们的手动安装与卸载adb install test.apk || adb unistall test.apk简单的两行命令实现我们的需要。 试想一下如果我们有这么一个需求，在测试的时候如果之前有一台手机安装过这个App，但是如果版本不一样，继续去安装，就会提示已存在，请卸载在安装，但是又没有命令帮我们，卸载还有安装同步执行哪，当然有了，adb install -r test.apk-r就是replace的意思，明白了吧。上面只是一些很简单，很小儿科的东西，下面我们讲一些高级一点，好玩的东西。adb pm || adb am || adb wm这是三个很重要的命令pm就是PackageManager，am就是ActivityManager，wm就是WindowManager。下面我们依次来看一看。pm试想我们有这么一个需求，就是我们所说的启动页，我们平时开发要做App的启动页大多数用Sp去做，但是这东西只有App第一次安装的时候才会出现，所以我们如果想测试，就必须卸载App然后安装App在进行测试，有没有命令帮我们搞定哪，有的同学会说了上面不是有卸载＋安装的命令啊，确实，但是这样显得有点Low，下面我们可以这样做。adb shell pm clear packageName清空我们App的缓存，相当于App第一次安装。可能有的人又说了，我们自己的App可能知道包名，其他的怎么办哪？当然也是有办法的，adb shell pm list package查看手机所有的包名。在这些输出打印当中你可能会发现有手机系统自己的系统包名，有我们安装的第三方应用的包名，那这样可不可以区分哪，当然也是可以的。adb shell pm list package -3 || adb shell pm list package -s前者是列出第三方包名，后者是列出系统包名。我们还可以查看这些App的安装来源，路径。adb shell pm list package -i || adb shell pm list package -f还有一个命令打印出来的信息太全面了adb shell pm dump packageName源码在此，这个网站可以很好的帮我们在线查看Android源码Pm.java下面我们来看am顾名思义，通过它我们可以启动一些和四大组件相关的东西。for example我们通过它来打开一个网页adb shell am start -a android.intent.action.VIEW -d http://www.baidu.com神奇的一幕出现，回车，手机上面自己打开了一个网页。如果我们还想让它打电话adb shell am start -a android.intent.action.CALL -d tel:10086刚刚说了是启动四大组件，那肯定是和他们有关系啊。启动一个serviceadb shell am startservice -n packageName/claaName解释一下，为什么上面是-a，这个是-n实际上这个地方写-n也行，区别就是-a是action的意思，-n是name的意思，service的路径一定要写全。adb shell am broadcast -a actionnameadb shell am startactivity -n classname不解释。Am源码在此Am.java最后一个看看Wm是和手机屏幕打交道的一个命令。它可以帮我们取出手机的尺寸，密度等信息adb shell wm sizeadb shell wm density一个尺寸一个密度，完美源码在此Wm.java今天的东西比较实用，后面可能还会继续去写这个东西，最近爱上了命令这个东西，因为Mac上面的终端实在是太可爱了，各位晚安，夜深了！！！！ 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android奇技淫巧</tag>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白学Android之adb篇(二)]]></title>
    <url>%2F2016%2F04%2F14%2Fadb-study-02%2F</url>
    <content type="text"><![CDATA[上一篇我们一起来看过adb的基础用法，这一次我们一起来看看adb logcat的用法 它在as中是长这样的这是界面化的，今天要说的是他的命令，有几个比较实用而且比较重要的。第一篇就说过学命令之前把他的help敲出来看看是什么，我们敲了adb logcat --help出来下面这些，仅部分，可自敲看看。 有人会提出这样的质疑，as里面的logcat不是很好用吗，而且还很友好，但是不知道你有没有遇到这种情况，就是有某几款手机是没有log的或者在茫茫log中找我们的报错原因，甚至还找不到，或者有的就是一闪而过的log，是不是有种想骂街的冲动，没事，我们不是还有命令啊。下面我以一个简单的demo来看看今天的logcat，在你的终端当中输入adb logcat会把你所有的log都输出来，这肯定不是我们想要的，我们要对他进行过滤，先看看as中的输出 我对他进行了过滤显示这样，我们在终端只需这样， adb logcat -s test后面的test就是我们所说的tag，过滤 输出就这样，如果你继续操作，adb logcat只会累加，我们能不能执行一次，log就是我们所需要的那，可以，就是把之前的清掉就好了，adb logcat -c执行清空操作。已经简单了解过后我们下面来看看adb logcat -v这个命令adb logcat -v --help 下面我们一起来看看其中的几个adb logcat -v time -s test打印时间这一列 adb logcat -v process -s test打印进程这一列 adb logcat -v raw -s tag只打印我们log的内容，没有tag等其他信息 adb logcat -v long -s tag几乎会把所有的log信息给我们 adb logcat|grep -s tag前面输出的内容当作grep的输入内容作为检索条件过滤 adb logcat -c&amp;&amp;adb logcat -s tag先清除再打印。 adb logcat -s AndroidRuntime当我们应用程序崩溃时有一些异常是捕捉不到的。这一招是很有用的 adb logcat&gt;&gt;log.txt将我们的log信息导出到文件当中 下面用vim打开vim log.txt已经把log写入了。成功 今天的logcat就先到这里吧 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android奇技淫巧</tag>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小白学Android之adb篇(一)]]></title>
    <url>%2F2016%2F04%2F12%2Fadb-study%2F</url>
    <content type="text"><![CDATA[今天我们开始学习adb了！！！ Android开发中从Eclipse到现在的AndroidStudio，ADB起了主导作用，但是我们真正用命令来操控adb的时候并不多，开始windows上面的adb，经常被别人占用端口，现在换了Mac，这些困扰的问题也少了很多。今天就和大家一起来学习学习adb的使用，开篇比较简单。adb在sdk中的platform-tools下，我们要把他配置到环境变量下，基于Mac。可以看我之前的一篇快速配置adb这里就不说了。 adb version 显示Android Debug Bridge version 1.0.35 Revision 102d0d1e73de-android这是我的adb版本，我们能看出来，adb的全称Android Debug Bridge。 我们在使用任何命令之前记得敲他的help肯定没有错，我们输入adb help这里只贴出一部分如果你对英文技术文档很敏感，完全可以自己明白这些命令的意思，无非就是adb后面加上他呗。下面我们捡几个重要的一起来看一下。我们一起来看一下，如果我们想知道我们的电脑上有几个设备，输入adb devices我这里有两个，一个是模拟器，一个是真机，那么我们如果要想针对某一个机器进行操作，我们输入adb shell但是给我们的却不是我们想要的，error: more than one device/emulator这并没有什么问题，因为你执行这么一句，机器并不知道你是要操作真机还是模拟器，所以我们要把他的序列码加上就好了。指定设备进行操作。help中有这么一行命令然后我门这样来搞，adb -s 4e934820 shell这里我们对我们的真机进行操作，回车这里已经成功进入到我们的真机，输入ls，查看真机的所有目录输入exit退出。还有一种方法感觉高大上，还是回顾我们的help命令有这么两行，可以简单帮我们搞定-d 也就是我们的USBDevice-e 也就是我们的emulator。上面输入序列码的操作可以简单成adb -d shell|| adb -e shell直接对真机或者模拟器进行操作。我们已经成功打入到我们的设备内部，那如果我们想从设备中拿我们需要的东西怎么办，或者把我们电脑上的东西放到我们的设备中去怎么办help中有这么两个命令，是不是很熟悉，和我们在git中使用的场景含义差不多，如果你想把你想把你电脑上的东西放到设备中去，执行push吧，反之执行pull吧。干巴巴的说没意思，我们在终端上玩一把我们对Desktop进行ls，上面有一个API_KEY.txt文件，我们打算把它推送到我们的真机上面，下面来看看我们来看看手机里面有吗发现已经成功的推到我们的设备了，反之我们怎么办，把API_KEY.txt拿到我们的电脑上面，首先我们把电脑上的rm掉rm API_KEY.txt然后此时已经成功放到我们的桌面了。 下一篇会和大家一起来看看adb logcat的用法 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android奇技淫巧</tag>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SublimeText查看Android源码配置]]></title>
    <url>%2F2016%2F03%2F17%2FSublimeText-AndroidSourceConfig%2F</url>
    <content type="text"><![CDATA[之前在Windows上面是用Source Insight查看源码，换做Mac开发之后发现SublimeText(下面简称ST)也很棒，之前一直在简单的用，还有一些奇技淫巧没发现，最近想好好的用下他，才把他通通的配置了一番。记录记录，有技巧，有填坑。 首先你要下载ST，还有Android源码。才能接着往下走。 安装Package Control插件首先打开控制台：view-&gt;showConsole然后输入以下代码，回车 1import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read()) 等一会，重启ST，然后到Preferences里面看一下是否有Package Control，有你就成功了。 安装CTags打开你刚刚安装的Package Control，接着输入install package，回车，然后输入ctag，出现的话就是你没安装过，没有的话你已经安装过。可以到Preference -&gt; Browse Packages里面查看你安装过的插件。直接Open你的文件，这时你在打开的文件中，右键菜单中会多一个Navigate to Definition菜单项，在侧左栏的工程/项目文件上右键会看到CTags: Rebuild Tags菜单项，这种种迹象表明你已经安装成功，只是安装成功，能不能使用，再说。 使用Ctags如果你右键看到CTags: Rebuild Tags菜单项，并点击它，下面会出现.tags文件，则已经成功，可以直接跳到下一步。如果没有的话，你要检查一下你Open的文件路径是不是中文路径，或者根据情况来定位。 Ctags配置一切Ctags默认的属性设置都在Preference -&gt;PackageSetting-&gt;Ctags下面。我们需要做的是首先将Setting default中的配置全部复制到user中，然后改一下command配置项，为ctags的可执行文件路径/usr/local/bin/ctags。默认的点击方法跳转的快捷键是ctrl+shift+鼠标左键，我们可以将其修改了，我们把Mouse Binding default中的配置全部复制到user中，然后修改modifiers中的属性，将其全部改为command，这样就OK了。 一些快捷键Command+P：查找文件Command+R：查找方法Command+左键：文件或函数跳转Command+右键：返回文件或函数跳转的原始位置 另外推荐几个ST的插件我们在使用AS的时候，格式化代码是一件很爽的事情，command+alt+L，格式化代码，但是在ST上面一个插件也可以实现Alignment，安装方法同上，快捷键是ctrl+shift+A。所有的插件都是通过install package进行查找安装的。 推荐：Sublime Text 有哪些使用技巧？版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Android奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus的一些记录]]></title>
    <url>%2F2016%2F03%2F15%2FThinkInEventBus%2F</url>
    <content type="text"><![CDATA[之前项目中用到过EventBus，之前只是单纯的用，最近在项目中再一次拿出来，就记录一下吧，当复习了。看下面的GIF，大致的表达了EventBus的工作形式。 简介借Github上面一张图来看一下EventBus是怎么工作的吧， Eventbus是一个事件优化管理平台，可以将它想像成Android BroadCast&amp;BroadcastReceiver的轻量版，以事件驱动的方式来简化事件处理逻辑，平时开发是以callback或handler来达到类似效果。如果物件之间传递经过太多其他物件；或是一个信息经过太多物件，EventBus将会是一个不错的选择。优点是开销小，代码更优雅。以及将发送者和接收者解耦。 使用场景我们试想一个简单的场景，在Profile页面，我们想修改我们的个人资料，进入到修改资料页面，修改成功返回到Profile页面，我们要将修改成功的资料显示到当前页面，一种是在Profile页面onResume方法中重新进行一次网络请求，另一种就是用事件传递，我们今天讲的，是第一种用户体验好，还是第二种体验好，可想而知，这只是一个简单的使用场景，我们还可以跨页面进行事件传递等等更深奥的用法。 如何使用1. gradle中 compile &#39;org.greenrobot:eventbus:3.0.0&#39;2. 定义自己的事件123456789public class WhateverEvent &amp;#123; /*事件可任意String, int, Object...*/ private String message public WhateverEvent(String message)&amp;#123; this.message = message; &amp;#125; public String getMessage()&amp;#123; return message;&amp;#125; 3. 注册，反注册EventBusgetDefault()为EventBus中的单例模式12345678910public static EventBus getDefault() &amp;#123; if (defaultInstance == null) &amp;#123; synchronized (EventBus.class) &amp;#123; if (defaultInstance == null) &amp;#123; defaultInstance = new EventBus(); &amp;#125; &amp;#125; &amp;#125; return defaultInstance; &amp;#125; 也可以建立自定义的EventBus。注册,反注册的代码是这样的。1234567891011121314public class MainActivity extends AppCompatActivity &amp;#123; ... @Override protected void onResume() &amp;#123; super.onResume(); EventBus.getDefault().register(this); &amp;#125; @Override protected void onPause() &amp;#123; super.onPause(); EventBus.getDefault().unregister(this); &amp;#125; ...&amp;#125; 记得写unregister()，不然会内存泄露（memory leak）。 4.订阅事件（接收消息）共有四个函数，各功能不同，这里先写其中的一个。123456789public class MainActivity extends AppCompatActivity &amp;#123; ... @Subscribe public void onEvent(WhateverEvent event) &amp;#123; /*处理事件*/ Log.i("TAG", event.getMessage()); &amp;#125;; ...&amp;#125; onEvent() 的paremeter为订阅的事件，也就我们的第二步中我们写的。 5.传送事件（发送消息）这个就很简单了eventBus.post(new AnyEventType event);大致的介绍了一遍，不知道你们晕了吗，那么上面的GIF图用代码实现，应该就很简单了吧。就是两个Activity，每一个Activity里面又一个Button，然后进行事件的传递。由于我们是在第一个页面点击按钮进入到第二个页面，那么我们在第一个页面注册以及反注册，然后在第二个页面post消息就好了。完整的代码奉上 MainActivity：123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity &amp;#123; TextView tv_event_info; @Override protected void onCreate(Bundle savedInstanceState) &amp;#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //注册eventbus EventBus.getDefault().register(this); tv_event_info = (TextView) findViewById(R.id.text); &amp;#125; public void startTo(View v) &amp;#123; startActivity(new Intent(this, SecondActivity.class)); &amp;#125; @Override protected void onDestroy() &amp;#123; super.onDestroy(); //反注册EventBus EventBus.getDefault().unregister(this); &amp;#125; @Subscribe public void onEventMainThread(EventInfo event) &amp;#123; String msg = "onEventMainThread收到了消息：" + event.getInfo(); tv_event_info.setText(msg); Toast.makeText(this, msg, Toast.LENGTH_LONG).show(); &amp;#125;&amp;#125; SecondActivity：12345678910111213public class SecondActivity extends AppCompatActivity &amp;#123; @Override protected void onCreate(Bundle savedInstanceState) &amp;#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); &amp;#125; public void gotoFirst(View v) &amp;#123; EventBus.getDefault().post(new EventInfo("这是EventBus给你的")); finish(); &amp;#125;&amp;#125; EventInfo:1234567891011public class EventInfo &amp;#123; private String mInfo; public EventInfo(String info) &amp;#123; mInfo = info; &amp;#125; public String getInfo() &amp;#123; return mInfo; &amp;#125;&amp;#125; 其中的onEvent()我写的是onEventMainThread(),这里onEvent()可替换成 onEventMainThread(), onEventBackgroundThread(), onEventAsync()来指定要在哪个Thread执行。Sticky event﹔事件发送完成不会马上消失 ，任何注册sticky event的class可以马上收到最后一则sticky event。如果你要进行代码混淆，记得在你的proguard.cfg中加入123 -keepclassmembers class ** &amp;#123; public void onEvent*(**);&amp;#125; 相关文章推荐：Android解耦库EventBus的使用和源码分析EventBus老家Github最近EventBus3更新了，来看看腾讯的老司机是怎么飙EventBus3的吧 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>实战小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android中Notification的PendingIntent无效问题解决]]></title>
    <url>%2F2016%2F03%2F11%2FThinkInPendingIntent%2F</url>
    <content type="text"><![CDATA[下面来一段代码，引出今天的梗 1234567891011121314151617181920NotificationManager nm = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);Intent intent = new Intent();intent.setClass(context, MainActivity.class);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);intent.putExtra("aa","bb");PendingIntent mPendingIntent = PendingIntent.getActivity(context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);Notification mNotification;if (android.os.Build.VERSION.SDK_INT &lt; 16) &amp;#123; mNotification = new Notification(); mNotification.icon = R.drawable.ic_launcher;// icon 的id mNotification.defaults = Notification.DEFAULT_ALL; mNotification.flags = Notification.FLAG_AUTO_CANCEL;&amp;#125; else &amp;#123; mNotification = new Notification.Builder(context) .setContentTitle(title).setContentText(message) .setSmallIcon(R.drawable.ic_launcher) .setDefaults(Notification.DEFAULT_ALL) .setAutoCancel(true).setContentIntent(mPendingIntent).build();&amp;#125;nm.notify(0, mNotification); 上面的代码就是最基本的消息通知，然后启动相应的界面，现在世面上大多数也都是这么写的，但是最近却栽在这个坑上了，为啥这么说，因为当我们消息推送的时候在其他机型这样写都是OK的，唯独在华为上面，点击消息启动栏没有任何反应，也不闪退，也不给我们答案，就是通知状态没有了。纠结了一阵子，今天终于。。。。我们先来看一下，作用于此事件的幕后黑手究竟是谁，上面的代码一目了然，PendingIntent.getActivity(Context context, int requestCode, Intent intent, int flags)，nm.notify(0, mNotification);就是这两个方法在搞怪，我们来看看里面的参数，PendingIntent.getActivity)官方的解释是这样的 Retrieve a PendingIntent that will start a new activity, like calling Context.startActivity(Intent). Note that the activity will be started outside of the context of an existing activity, so you must use the Intent.FLAG_ACTIVITY_NEW_TASK launch flag in the Intent. 主要的意思就是使用PendingIntent来启动一个Activity，就像用Context.startActivity(Intent)来启动一个Activity一样，注意这里的activity将是上下文之外现有的activity，所以你必须使用Intent.FLAG_ACTIVITY_NEW_TASK标记位来启动一个intent。 这里面的第一个，第三个参数这里不打算细说了。 123456789* @param context The Context in which this PendingIntent should start* the activity.* @param requestCode Private request code for the sender* @param intent Intent of the activity to be launched.* @param flags May be &amp;#123;@link #FLAG_ONE_SHOT&amp;#125;, &amp;#123;@link #FLAG_NO_CREATE&amp;#125;,* &amp;#123;@link #FLAG_CANCEL_CURRENT&amp;#125;, &amp;#123;@link #FLAG_UPDATE_CURRENT&amp;#125;,* or any of the flags as supported by* &amp;#123;@link Intent#fillIn Intent.fillIn()&amp;#125; to control which unspecified parts* of the intent that can be supplied when the actual send happens. 摘自源码，当我们点进去getActivity方法时是这样的 1234567891011121314151617181920212223public static PendingIntent getActivity(Context context, int requestCode, Intent intent, @Flags int flags) &amp;#123; return getActivity(context, requestCode, intent, flags, null); &amp;#125;public static PendingIntent getActivity(Context context, int requestCode, @NonNull Intent intent, @Flags int flags, @Nullable Bundle options) &amp;#123; String packageName = context.getPackageName(); String resolvedType = intent != null ? intent.resolveTypeIfNeeded( context.getContentResolver()) : null; try &amp;#123; intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); IIntentSender target = ActivityManagerNative.getDefault().getIntentSender( ActivityManager.INTENT_SENDER_ACTIVITY, packageName, null, null, requestCode, new Intent[] &amp;#123; intent &amp;#125;, resolvedType != null ? new String[] &amp;#123; resolvedType &amp;#125; : null, flags, options, UserHandle.myUserId()); return target != null ? new PendingIntent(target) : null; &amp;#125; catch (RemoteException e) &amp;#123; &amp;#125; return null; &amp;#125; 第四个参数Flag我挨个换了一遍还是不行，排除法，最后剩下requestCode了，可是网上都是这么写的啊，不然，就是他的原因。我们可以从源码中可以看出来，我们把requestCode传进去之后，重新传给了IIntentSender对象，看源码涉及到IPC机制，贴出getIntentSender()源码 1234567891011121314151617181920212223242526272829303132333435public IIntentSender getIntentSender(int type, String packageName, IBinder token, String resultWho, int requestCode, Intent[] intents, String[] resolvedTypes, int flags, Bundle options, int userId) throws RemoteException &amp;#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IActivityManager.descriptor); data.writeInt(type); data.writeString(packageName); data.writeStrongBinder(token); data.writeString(resultWho); data.writeInt(requestCode); if (intents != null) &amp;#123; data.writeInt(1); data.writeTypedArray(intents, 0); data.writeStringArray(resolvedTypes); &amp;#125; else &amp;#123; data.writeInt(0); &amp;#125; data.writeInt(flags); if (options != null) &amp;#123; data.writeInt(1); options.writeToParcel(data, 0); &amp;#125; else &amp;#123; data.writeInt(0); &amp;#125; data.writeInt(userId); mRemote.transact(GET_INTENT_SENDER_TRANSACTION, data, reply, 0); reply.readException(); IIntentSender res = IIntentSender.Stub.asInterface( reply.readStrongBinder()); data.recycle(); reply.recycle(); return res; &amp;#125; 这里首先获取Parcel对象，Parcel.obtain(),然后将我们传递过来的参数打包到Parcel对象中，parcel.write(),最后将我们打包好的数据发送出去 mRemote.transact(),最后回收parcel对象，data.recycle();reply.recycle();猜测应该是sender用requestCode来区分不同的PendingIntent对象，然后对应。因为之前我们传递的都是0，所以这里我们将requestCode的值改为每条消息都不一样就好了。这里也要记住，getActivity中requestCode和notiy中的id要保持一致，我将这里改成了 12PendingIntent mPendingIntent = PendingIntent.getActivity(context, (int)System.currentTimeMillis()/1000, intent, PendingIntent.FLAG_UPDATE_CURRENT);nm.notify((int) (System.currentTimeMillis()/1000), mNotification); 这样就解决问题了。 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>埋坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ScrollView中嵌套滚动控件手势解决]]></title>
    <url>%2F2016%2F03%2F08%2FScollGesturesConflictSolve%2F</url>
    <content type="text"><![CDATA[今天做项目时遇到这么一个场景，在一个ScrollView中需要有一个时间选择控件，就是仿的iOS时间选择那种，布局实现很简单很快实现，可是就是在玩的时候，轮子滚动和外层的ScrollView滚动起了一点摩擦。一上来就想到的是事件冲突了。最终有这么一个简单的方法。 1234567891011listView.setOnTouchListener(new View.OnTouchListener() &amp;#123; @Override public boolean onTouch(View v, MotionEvent event) &amp;#123; if (event.getAction() == MotionEvent.ACTION_UP) &amp;#123; mSrollView.requestDisallowInterceptTouchEvent(false); &amp;#125; else &amp;#123; mSrollView.requestDisallowInterceptTouchEvent(true); &amp;#125; return false; &amp;#125; &amp;#125;); mSrollView.requestDisallowInterceptTouchEvent()这句话的意思就是告诉父view不要拦截此事件，哥自己来处理就好。对listview，scrollView，recycleView都适用。 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android事件处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试时候一些问题回答]]></title>
    <url>%2F2016%2F03%2F06%2FAndroid-zhihu-question%2F</url>
    <content type="text"><![CDATA[现在已经就职阿里巴巴－菜鸟的Android工程师马天宇，一个月面试了杭州10几家有名的互联网公司，一次分享，我帮忙整理了一下，整理到了知乎上面，一些架构师才会考虑的面试题，有一些深度，帮大家扩展知识面，但是下面给出的经典答案，大家可以点击查看。都是用心在回答的，很赞。 整体性能如何探测，有哪方面 什么指标，怎么保证更流畅 讲讲架构这块，如何解耦，大项目逻辑多怎么办。 android的发展大事件和主要技术发展 avtivity（service）启动流程简述 动态化的几种方案 热修复的原理 网络这块怎么优化 数据库性能怎么保证 线程安全怎么保证，异步并发这块你怎么做的 原文链接 知乎欢迎关注😊 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>面试回答</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidSupportLibrary23.2重磅更新]]></title>
    <url>%2F2016%2F02%2F25%2FAndroidSupportLibrary23-2%2F</url>
    <content type="text"><![CDATA[2月25凌晨Google正式发布了android-support-library-23.2支持库，一大早微信群里面都在热议不止，开发者们的福音。这一次23.2版本增加了一些新的支持库以及新的功能，许多现有的库，还把之前的library小学生问题修复了，可喜可贺。闲言碎语不要讲，直接切入正题。(文中链接记得自备梯子) YouTube观看链接Android Support Library 原文Android Developers Blog 中文翻译本次更新主要涉及： Support Vector Drawables and Animated Vector Drawables AppCompat DayNight theme Design Support Library: Bottom Sheets Support v4: MediaBrowserServiceCompat RecyclerView Custom Tabs Leanback for Android TV 1.Support Vector Drawables and Animated Vector Drawables(支持矢量图片和矢量图片动画) Vector Drawables让你用一个矢量图片，替换定义在XML中的多个PNG资源。而此前只支持L版本或者更高的设备版本，通过support-vector-drawable和support-animated-vector-drawable两新的支持库分别支持矢量图片和矢量图片动画。AndroidStudio1.4已经引入过矢量绘图支持在构建时生成PNG图像。要想禁用此功能(并想使用最新支持库)，你需要在你的build.gradle里面添加vectorDrawables.useSupportLibrary = true 123456// Gradle Plugin 2.0+ android &amp;#123; defaultConfig &amp;#123; vectorDrawables.useSupportLibrary = true &amp;#125; &amp;#125; 你会发现这个新的属性只在AndroidStudio2.0版本存在。如果您使用的是AndroidStudio1.5，需要 1234567891011// Gradle Plugin 1.5 android &amp;#123; defaultConfig &amp;#123; generatedDensities = [] &amp;#125; // This is handled for you by the 2.0+ Gradle Plugin aaptOptions &amp;#123; additionalParameters &quot;--no-version-vectors&quot; &amp;#125; &amp;#125; VectorDrawableCompat支持API7+，AnimatedVectorDrawableCompat支持API11+。由于android的图片加载机制的限制，不是所有支持图片id的地方（例如xml文件里）都能使用矢量图。值得一体的是，AppCompat已经增加了许多功能，可以很容易地使用新的矢量绘图资源。首先，当我们在ImageView(或子类，如ImageButton和FloatingActionButton)中使用Appcomat，你就可以使用新属性app:srcCompat来引用矢量图片（也可以在android:src中以及任何其他可用的地方使用图片)。 1234&lt;ImageView android:layout_width = &quot;wrap_content&quot; android:layout_height = &quot;wrap_content&quot; app:srcCompat = &quot;@drawable/ic_add&quot; /&gt; 如果你在运行时(java代码中)更改drawable，你也可以使用相同的setImageResource()和以前一样没有变。使用AppCompat和 app:srcCompat是将矢量图片集成到app的最简单的方法。你会发现在L版本中不使用app:srcCompat引用矢量图都是无效的。然而，当矢量图被另一个drawable container(例如StateListDrawable，InsetDrawable，LayerDrawable，LevelListDrawable和RotateDrawable )引用时，AppCompat是可以加载的。所以，在一些无法直接使用AppCompat（直接使用app:srcCompat）的地方通过这种间接使用，也可以在矢量图片中使用类似 TextView’s android:drawableLeft属性。 2.AppCompat DayNight theme(DayNight 主题) 此前API14，该DayNight主题以及DayNight.NoActionBar， DayNight.DarkActionBar，DayNight.Dialog等等，提供了相同的亮度。但在API 14和更高版本的设备，这个主题可以让应用程序可以轻松地支持 白天和夜晚的主题，根据是否是“夜晚”来决定主题是否从白天切换到夜晚主题。默认情况下，是否是“夜晚”是由系统值(UiModeManager.getNightMode())决定，但你可以重写该方法AppCompatDelegate中的值来设置。你将能够在整个应用程序中设置默认值（直到进程重新启动）与静态AppCompatDelegate.setDefaultNightMode()或通过 getDelegate()) 得到AppCompatDelegate对象，并使用setLocalNightMode()来设置当前的Activity或Dialog的主题。当使用AppCompatDelegate.MODE_NIGHT_AUTO，它会时刻知道你最后的位置和时间（如果您的应用程序已开启位置权限）用于白天和黑夜之间自动切换的依据。MODE_NIGHT_NO 和 MODE_NIGHT_YES 则分别强制设定了从不或是一直使用夜晚主题。这是您在使用白天主题的时候彻底测试你的应用程序的关键，因为白天主题的亮度很可能导致一些文字或者图标变得不可阅读。如果您使用的是标准TextAppearance.AppCompat 从你的主题样式android:textColorPrimary为你的文本或颜色，你会发现这些为你自动更新。 3.Design Support Library: Bottom Sheets(材料设计，底部表) 通过附加一个BottomSheetBehavior到子视图的CoordinatorLayout(添加app:layout_behavior =“android.support.design.widget.BottomSheetBehavior”)，通过对BottomSheet的操作我们可以得到它的五种状态。 STATE_COLLAPSED：关闭Bottom Sheets，高度可控属性app:behavior_peekHeight（默认为0） STATE_DRAGGING：在用户直接拖动Bottom Sheets向上或向下的中间状态 STATE_SETTLING：当Bottom Sheets被释放和沉降到其最终位置记录的状态 STATE_EXPANDED：Bottom Sheets展开时的状态 STATE_HIDDEN：默认情况下禁用(和启用应用程序：behavior_hideable属性),这使得用户可以向下滑动Bottom Sheets完全隐藏底部 请记住，你的底部滚动容器必须支持嵌套滚动(例如，NestedScrollView, RecyclerView, or ListView/ScrollView on API 21+)。如果需要监听Bottom Sheets回调时的状态，可以通过BottomSheetCallback来实现。 12345678910111213// The View with the BottomSheetBehavior View bottomSheet = coordinatorLayout.findViewById(R.id.bottom_sheet); BottomSheetBehavior behavior = BottomSheetBehavior.from(bottomSheet); behavior.setBottomSheetCallback(new BottomSheetCallback() &amp;#123; @Override public void onStateChanged(@NonNull View bottomSheet, int newState) &amp;#123; // 监听上述5种状态的变化 &amp;#125; @Override public void onSlide(@NonNull View bottomSheet, float slideOffset) &amp;#123; // 拖拽中的回调 &amp;#125; &amp;#125;); 虽然BottomSheetBehavior能够捕获持续bottom sheet的情况，此版本还提供了一个BottomSheetDialog和BottomSheetDialogFragment填补了model bottom sheets使用情况。只需更换AppCompatDialog或AppCompatDialogFragment作为底片。 4.Support v4: MediaBrowserServiceCompat 该Support v4库用作许多支持库的基础，并且为一些新版本介绍的特征提供支持(backports)。添加到以前发布的MediaSessionCompat类，为媒体播放了提供了坚实的基础，这个版本增加了MediaBrowserServiceCompat和MediaBrowserCompat提供，带来了最新的API兼容的解决方案（甚至没有在L设备上加）支持API4+。这使得我们更容易地在Android上支持媒体的播放和在Android Wear上浏览媒体，为我们提供了一个标准的接口，让你的媒体播放服务与界面连起来。 5.RecyclerView 最新的RecyclerView目录结构如下 RecyclerView组件为我们提供了灵活的创建列表和网格以及动画的特性。这个版本带来一个激动人心的新特性LayoutManager API：自动测量！！！这允许RecyclerView尺寸大小根据其内容的大小尺寸定制。这意味着，先前不可用的情况，例如使用WRAP_CONTENT为尺寸的RecyclerView，现在都是可能的。你会发现所有内置的布局管理现在都支持自动测量。由于这种变化，一定要确保你的item的布局属性：以前被忽视的布局参数（如MATCH_PARENT的滚动方向）现在将不一样。如果你有一个自定义的LayoutManager并且不是基于之前的拓展，有一个选择就是你可以调用setAutoMeasureEnabled(true)，以及做一些小的变化（详情见Javadoc）来支持新特性注意，虽然RecyclerView支持动画，但是他不支持自己动画边界变化，如果你想对RecyclerView边界进行动画处理，你可以使用 Transition APIs. 6.Custom Tabs(自定义选项卡)。 Custom Tabs能够同时保持你的应用程序的外观和感觉无缝地过渡到Web内容。在这个版本中，您现在就可以行动加入底栏显示旁边的网页内容。 有了新加的addToolbarItem(),你现在可以在底栏增加五种动作，并且一旦会话开始就可以使用 setToolBarItem()更新他们，你还会发现一个setSecondaryToolbarColor()自定义底栏的背景颜色。 7.Leanback for Android TV AndroidTV请看原文，对这方面了解甚少，就不嚯嚯读者了。。 动手吧！！！Android的支持库的版本23.2是通过您的SDK管理器和Android Studio中更新可用。充分利用所有的新特性以及其他bug修复从现在开始！与往常一样，在提交错误报告b.android.com并与其他开发人员交流的Android开发Google+社群 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>最新</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio设置代理更新]]></title>
    <url>%2F2016%2F02%2F03%2FAndroidStudioProxy%2F</url>
    <content type="text"><![CDATA[最近AndroidStudio更新频繁，Preview几乎一天一个版本，但是我从3之后就升不上去了，期间更新几次一次Failure，就没管，因为我用的ShadowSocks，应该全局翻墙可以啊。不行就纳闷了，直到今天感谢群里一哥们，使用SS的哥们福音到了，请看这篇文章。 不好意思，把你骗进来了，嘿嘿，看下面的这个Blog应该能完美解决你的问题 AndroidStudio设置代理 亲测成功Update到了Preview9 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AndroidStudio小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义文本显示TextView]]></title>
    <url>%2F2016%2F01%2F31%2FCustomTextShow%2F</url>
    <content type="text"><![CDATA[现在的app，数据我们从后台拿到，然后显示在指定的区域，但是后台可能会包含一些html的标签，像&lt;a&gt;,&lt;b&gt;等等，我们总不能让用户看到这些内容，我们客户端处理一下就好了，自定义TextView就OK。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class MyCustomTextView extends TextView &amp;#123; public MyCustomTextView(Context context) &amp;#123; super(context); &amp;#125; public MyCustomTextView(Context context, AttributeSet attrs) &amp;#123; super(context, attrs); &amp;#125; public MyCustomTextView(Context context, AttributeSet attrs, int defStyle) &amp;#123; super(context, attrs, defStyle); &amp;#125; public void set(String comments) &amp;#123; if (comments.contains(&quot;&lt;&quot;)) &amp;#123; setText(Html.fromHtml(comments)); setMovementMethod(LinkMovementMethod.getInstance()); CharSequence text = getText(); if (text instanceof Spannable) &amp;#123; int end = text.length(); Spannable sp = (Spannable) getText(); URLSpan[] urls = sp.getSpans(0, end, URLSpan.class); SpannableStringBuilder style = new SpannableStringBuilder( text); style.clearSpans();// should clear old spans // 循环把链接发过去 for (URLSpan url : urls) &amp;#123; MyURLSpan myURLSpan = new MyURLSpan(url.getURL()); style.setSpan(myURLSpan, sp.getSpanStart(url), sp.getSpanEnd(url), Spannable.SPAN_EXCLUSIVE_INCLUSIVE); &amp;#125; setText(style); &amp;#125; &amp;#125; else &amp;#123; setText(comments); &amp;#125; &amp;#125; class MyURLSpan extends ClickableSpan &amp;#123; private String mUrl; MyURLSpan(String url) &amp;#123; mUrl = url; &amp;#125; @Override public void updateDrawState(TextPaint ds) &amp;#123; super.updateDrawState(ds); ds.setColor(Color.parseColor(&quot;#507daf&quot;)); ds.setUnderlineText(false); // 去掉下划线 &amp;#125; //处理链接点击事件 @Override public void onClick(View widget) &amp;#123; &amp;#125; &amp;#125;&amp;#125; 使用的时候直接在XML中引用就好了，然后java代码中显示我们要显示的内容。MyCustomTextView.set(content);就好了。 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>自定义UI</tag>
        <tag>实战小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[吐槽CollapsingToolbarLayout]]></title>
    <url>%2F2016%2F01%2F29%2FFuckAndroidSDK%2F</url>
    <content type="text"><![CDATA[今天真是日了狗了，之前在我们的项目中用到了CollapsingToolbarLayout，compileSdkVersion设置的22，因为有一些属性只有23才有，只好改成了23，不改不要紧，改完之后，CollapsingToolbarLayout的Title不显示了。。。。开始没想太多，以为自己写错了，或者改成23之后多了什么API，去了developer上面看了一下，没问题啊，Google了一番，说这是一个Google的bug，当时心中真是有一万只草泥马啊。。。但是吐槽归吐槽，如果你用不到Title的话，也可以改成23，里面有一个属性app:layout_scrollFlags=”snap”，这里面多了一个snap属性，就是当你上滑的时候如果一半，他不会停留，他会自动滑上去，而在22却没有，还有一些属性，22也没有，就是setCollapsedTitleGravity设置标题显示位置，现在标题都不出来了，这个属性也就显得无足轻重了。如果有好的解决方法，不妨告知。。。版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>随记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apk瘦身+Proguard混淆实战]]></title>
    <url>%2F2016%2F01%2F28%2FApkProguardStudy%2F</url>
    <content type="text"><![CDATA[很高兴，经过1天的时间，我们的apk从23M已经瘦到了17.9M，这里很感谢这篇博客给我带来的冲动，APK瘦身实践，这里面提到的如果都试过，肯定会有质的飞跃，我只试了几个，就带来了意想不到的收获，下面我们一起来见证这奇迹的时刻。 先上图当minifyEnabled＝false是这样的，也就是没代码混淆 对比7zip18.9M，普通的18.6M 当use7zip＝false是这样的，没开启7zip压缩 18.6M当全为true是这样的 对比7zip17.9M,普通18.6M用微信Android资源混淆工具打包完成后是这样的app/build/outputs/apk下面会多一个这样的文件夹AndResProguard 命令是╰─➤ ./gradlew generate，而不是./gradlew assembleRelease，如果你没用微信的那一套方法，用第二种就可以，如果你用了微信的那一套，必须用第一种口令了。微信的那一套在这里AndResGuard有中文文档，遇到问题可以参考里面的issues，当然里面也有我提的，嘿嘿。这里一些技巧，去除无用代码，无用图片啊，这里就不说了，上面推荐的文章里面说的很清楚。这里既然说的是apk瘦身+代码混淆。apk瘦身我这里靠的就是去除无用资源，优化图片，混淆代码实现的。最重要的还是代码混淆，我这里用了双重混淆，一种proguard-rules.pro文件进行混淆，一种微信混淆工具进行混淆，这两种上面的文章有提到。第一种主要就是把gradle中的开关打开，然后进行proguard-rules.pro的文件编写，因为这里是在As中进行的。注意：在使用Eclipse+ADT时需要加入-libraryjars libs/…，如果你是使用Android Studio开发的项目则不需要加入libs包中的jar包，这是因为，通过Android Studio进行混淆代码时，默认已经将 lib目录中的 jar 都已经添加到打包脚本中，所以不需要再次手动添加，否则会出现“ java.io.IOException: The same input jar is specified twice” 错误。我这里贴出来我写的一部分，结合你们自己的项目进行混淆，哪些进行混淆，哪些不能进行混淆。1.JavaBean类即实体类不被混淆。2.自定义控件不参与混淆。3.枚举不被混淆。4.第三方库中的类不进行混淆举一个例子。 12345#baidu-keep class com.baidu.** &amp;#123;*;&amp;#125;-keep class vi.com.** &amp;#123;*;&amp;#125;-dontwarn com.baidu.**-dontwarn vi.com.** 百度第三方库，这样写的意思是，-keep class com.baidu. &#123; *; &#125; 让ProGuard不要警告找不到com.baidu.这个包里面的类的相关引用-dontwarn com.baidu. 保持com.baidu.这个包里面的所有类和所有方法不被混淆。几乎第三方类都这样写就可以了，怎么找到它对应的包那，展开lib下面引用的第三方就可以了，还有一些是在gradle中加的，那就到这里找就好了 然后仿照上面的书写格式就好了。当你觉得写的差不多的时候打一个包出来，然后安装看看，我昨天就是一口气弄完，最后BUILD SUCCESSFUL了，但是安装到手机上面就是崩溃，还是有些不该混淆的类给混淆了，他找不到了。微信那一个Github的文档，还有一个demo应该能玩转了，就是如果开启7zip压缩，首先你电脑要有7zip，Mac上面安装很简单，brew install p7zip，然后把Github上面的那一段gradle复制进去，要对应好哦， 12345buildscript &amp;#123; dependencies &amp;#123; classpath &apos;com.tencent.mm:AndResGuard-gradle-plugin:1.1.2&apos; &amp;#125;&amp;#125; 这一段是放在Project中的gradle的，剩下的都是放在Module中gradle的。 参考资料： 代码混淆和破解apkAndroid Proguard 详解 Android 项目的代码混淆，Android proguard 使用说明 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>apk瘦身</tag>
        <tag>代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[猴年我也凑凑热闹]]></title>
    <url>%2F2016%2F01%2F28%2FHappyNewYear%2F</url>
    <content type="text"><![CDATA[最近朋友圈，微博被六小龄童上春晚刷屏了，我也来凑凑热闹吧！ 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>休息一下</category>
      </categories>
      <tags>
        <tag>开心一笑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[相机拍照即时保存，即时读取]]></title>
    <url>%2F2016%2F01%2F25%2FTakePhotoSave%2F</url>
    <content type="text"><![CDATA[拍照发feed，进入相机拍照界面，如果拍完了却不想发了，然后回到相册界面，要有你刚刚拍的那张，就是这么一个需求。 首先Camera的拍照方法camera.takePicture(null, null, new MyPictureCallback()); 回调接口 12345678910111213private final class MyPictureCallback implements Camera.PictureCallback &amp;#123; @Override public void onPictureTaken(byte[] data, Camera camera) &amp;#123; cameraParameters.setFlashMode(Camera.Parameters.FLASH_MODE_OFF); camera.setParameters(cameraParameters); try &amp;#123; saveToSDCard(data); // 保存图片到sd卡中 &amp;#125; catch (Exception e) &amp;#123; e.printStackTrace(); &amp;#125; &amp;#125;&amp;#125; 下面就是这次我们要讲的重点了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public void saveToSDCard(byte[] data) throws IOException &amp;#123; File photo = this.getPhotoPath(); if (photo.exists()) &amp;#123; photo.delete(); &amp;#125; Bitmap bmp = BitmapFactory.decodeByteArray(data, 0, data.length); Matrix matrix = new Matrix(); //此处的degree有两个值，预防拍照反转，90度和270度，三星手机操蛋。你要判断处理一下，是90还是270. matrix.postRotate(degree); int width = bmp.getWidth(); int height = bmp.getHeight(); bmp = Bitmap.createBitmap(bmp, 0, 0, width, height, matrix, true); try &amp;#123; FileOutputStream e = new FileOutputStream(photo.getPath()); BufferedOutputStream bos = new BufferedOutputStream(e); bmp.compress(Bitmap.CompressFormat.JPEG, 100, e); bos.write(data); //如果要想把data保存到disk上面，你必须flush and sync刷新并同步一下 bos.flush(); e.getFD().sync(); bos.close(); if (scanSavedImage) &amp;#123; MediaScannerConnection.scanFile(getActivity(), new String[]&amp;#123;photo.getPath()&amp;#125;, SCAN_TYPES, null); &amp;#125; &amp;#125; catch (IOException ie) &amp;#123; Log.e(this.getClass().getSimpleName(), "Exception in setPreviewDisplay()", ie); &amp;#125; try &amp;#123; //拍照完成跳到裁剪界面的逻辑处理 Intent intent = this.getIntent(); startActivity(intent); finish(); &amp;#125; &amp;#125; catch (Throwable e) &amp;#123; e.printStackTrace(); &amp;#125; &amp;#125; protected File getPhotoPath() &amp;#123; File dir = this.getPhotoDirectory(); dir.mkdirs(); return new File(dir, this.getPhotoFilename()); &amp;#125; protected File getPhotoDirectory() &amp;#123; if (this.photoDirectory == null) &amp;#123; this.initPhotoDirectory(); &amp;#125; return this.photoDirectory; &amp;#125; private void initPhotoDirectory() &amp;#123; this.photoDirectory = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM); &amp;#125; protected String getPhotoFilename() &amp;#123; String ts = (new SimpleDateFormat("yyyyMMdd_HHmmss", Locale.US)).format(new Date()); return "Photo_" + ts + ".jpg"; &amp;#125; 这些代码拿进你的项目就可以用。 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Androiod相机拍照</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查看更多效果实现]]></title>
    <url>%2F2016%2F01%2F18%2FViewMoreDetailText%2F</url>
    <content type="text"><![CDATA[最近在乐视App上面看电影，看见每个视频下面都有一个视频详情，点击查看更多效果,想着实现一个这样的效果。类似下面这种 我的第一反应是自定义一个View出来，然后根据传递的文字长度进行截取显示，但是做的时候发现也可以不用自定义，一种比较投机取巧的方法，一起看看。 首先我们先自定义开始要显示的行数。 123456private static final int LIMIT = 2;private int currentLines; currentLines = LIMIT;desc.setMaxLines(currentLines);desc.setText("苍井空，1983年11月11日出生于日本东京。日本AV女演员、成人模特，兼电视、电影演员。日本女子组合惠比寿麝香葡萄的初代首领，现成员、OG首领。2010年3月毕业并将组合首领之位交托给麻美由真，同年10月复归。入行前曾是泳装写真女星，2002年进入AliceJapan公司，开始性感影片的拍摄生涯。因为其“童颜巨乳”的特色，开始获得人气，并连续在2003年及2004年蝉联日本《VideoBoy》杂志年度性感女艺人第一名。"); 下面我们对内容存放的区域进行高度的计算。 1234567891011121314151617181920212223int FULLSIZE = -1;int THUMBNAIL =-1;contentView.addOnLayoutChangeListener(new View.OnLayoutChangeListener() &lt; @Override public void onLayoutChange(View view, int i, int i2, int i3, int i4, int i5, int i6, int i7, int i8) &lt; bg.getLayoutParams().height = contentView.getHeight(); bg.requestLayout(); if(THUMBNAIL == -1) &lt; THUMBNAIL = contentView.getHeight(); &amp;#125; if(FULLSIZE == -1) &lt; FULLSIZE = THUMBNAIL + getTextViewHeight(desc) - desc.getHeight(); &amp;#125; &amp;#125; &amp;#125;); private int getTextViewHeight(TextView pTextView) &lt; Layout layout = pTextView.getLayout(); int desired = layout.getLineTop(pTextView.getLineCount()); int padding = pTextView.getCompoundPaddingTop() + pTextView.getCompoundPaddingBottom(); return desired + padding; &amp;#125; 当我们点击按钮的时候会执行一个动画，然后完全展示出来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970showDetailButton.setOnClickListener(new View.OnClickListener() &lt; @Override public void onClick(View view) &lt; if(currentLines == LIMIT) &lt; expand(contentView, THUMBNAIL, FULLSIZE); &amp;#125; else &lt; expand(contentView, FULLSIZE, THUMBNAIL); &amp;#125; Animation animation = new RotateAnimation( currentLines == LIMIT ? 0 : 180, currentLines == LIMIT ? 180 : 360, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f); animation.setDuration(300); animation.setFillAfter(true); showDetailButton.startAnimation(animation); contentView.requestLayout(); &amp;#125; &amp;#125;); public void expand(final View v, final float originHeight, final float targetHeight) &lt; Animation a = new Animation()&lt; @Override protected void applyTransformation(float interpolatedTime, Transformation t) &lt; v.getLayoutParams().height = (int)(originHeight + (targetHeight - originHeight) * interpolatedTime); v.requestLayout(); &amp;#125; @Override public boolean willChangeBounds() &lt; return true; &amp;#125; &amp;#125;; a.setDuration(600); a.setFillAfter(true); a.setAnimationListener(new Animation.AnimationListener() &lt; private boolean maxLineDidSet = false; @Override public void onAnimationStart(Animation animation) &lt; if(currentLines == Integer.MAX_VALUE) &lt; currentLines = LIMIT; desc.setMaxLines(currentLines); maxLineDidSet = true; &amp;#125; &amp;#125; @Override public void onAnimationEnd(Animation animation) &lt; if(!maxLineDidSet &amp;&amp; currentLines == LIMIT) &lt; currentLines = Integer.MAX_VALUE; desc.setMaxLines(currentLines); &amp;#125; &amp;#125; @Override public void onAnimationRepeat(Animation animation) &lt; &amp;#125; &amp;#125;); v.startAnimation(a); &amp;#125; 基本所有的代码都在这里了，主要就是一个内容区域的高度计算，一个动画的展示。不算完美的实现了展开更多的效果。 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android UI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iTerm新手必知]]></title>
    <url>%2F2016%2F01%2F12%2FiTermConfiguration%2F</url>
    <content type="text"><![CDATA[使用Mac自家的终端，一般来说就够用了，但是扩展性有点差，而且还不美观，这时有人给我们做了一个好玩，好看而且功能完全媲美Mac本家的终端，那就是大名鼎鼎的iTerm然后配上oh-my-zsh。先来几幅图 看到这些图，是不是被它的美震撼了啊，反正我是。下面说说他为什么值得我们去说。安装下载这里就不说了。 配色惊艳配色方案全在这里iTerm2-Color-Schemes打开偏好设置，找到这两个地方 先在配色方案里面找到自己喜欢的一种，然后要把上图中Type一定改为－new类型的。 然后找到colors选项，选自己喜欢的，即选即预览。快捷键，插件的强大 首先他的选中即复制就很强大，偶尔一次的ctrl＋c，按成了ctrl＋v，惊人的效果出现，竟然把我选中的东东复制粘贴了在后面。在偏好设置中的keys选项就是所有的快捷键，插件在推荐文章里面有 一些常用的。 视觉美最上面的两幅图是不是很惊艳，但是他可以弄出你自己想要的效果，具体在这里。将iTerm2背景设为半透明 将iTerm2全屏呈现在窗口之上 这里说下第二幅图什么意思，就是当前不管你在浏览什么窗口，只要你设置了快捷键，按下就会出现，比如我这个，我在AS的界面，但是我想查点什么东西，按下command＋\键，就会浮现在桌面的最顶端。命令行提示演示效果 在下面的推荐文章你还会找到一个命令行提示的，自行挖掘把，嘿嘿 推荐文章终极 Shell——ZSH - MacTalk - 知乎专栏zsh与oh-my-zsh的区别mac下非常好用的命令行工具 iTerm2 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>iTerm配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio导项目时的一些问题]]></title>
    <url>%2F2016%2F01%2F11%2FAndroidStudioGradleIssue%2F</url>
    <content type="text"><![CDATA[这里陆陆续续的收录一些关于AS的问题。今天在GitHub上面发现一个好的项目，导入到AS里面竟发现不能运行，报的错误也是千奇百怪，1Error:Execution failed for task ':app:transformResourcesWithMergeJavaResForDebug'. &gt; com.android.build.api.transform.TransformException: com.android.builder.packaging.DuplicateFileException: Duplicate files copied in APK META-INF/NOTICE 有这么一排错误，Google了半天，要这样做，在你的gradle中加入123456789101112packagingOptions &amp;#123; exclude 'META-INF/DEPENDENCIES.txt' exclude 'META-INF/LICENSE.txt' exclude 'META-INF/NOTICE.txt' exclude 'META-INF/NOTICE' exclude 'META-INF/LICENSE' exclude 'META-INF/DEPENDENCIES' exclude 'META-INF/notice.txt' exclude 'META-INF/license.txt' exclude 'META-INF/dependencies.txt' exclude 'META-INF/LGPL2.1'&amp;#125; 还有一个问题如果你想在API23中使用AndroidHttpClient，必须要这么做。在你的build.gradle中加入123android &amp;#123; useLibrary 'org.apache.http.legacy'&amp;#125; 因为Android 6.0已经废弃了支持Apache HTTP client. 官方不建议使用了，如果迫不得已使用，加上那个就好了。 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AndroidStudio</tag>
        <tag>工程导入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用MaterDesign设计一个详情页面]]></title>
    <url>%2F2016%2F01%2F09%2FMaterDesignDemo%2F</url>
    <content type="text"><![CDATA[我们要实现的效果就是gif的那种效果，MaterDesign完美实现这个功能，下面我们一起来看看。在写代码之前记得在你的gradle里面加上这么两行 12compile 'com.android.support:appcompat-v7:23.1.1'compile 'com.android.support:design:23.1.1' 然后就可以在Xml里面写自己的布局了，先上代码，再解释属性。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true" tools:context="com.android.demo.MainActivity"&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width="match_parent" android:layout_height="256dp" android:fitsSystemWindows="true" android:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" &gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:id="@+id/collapsing_toolbar" android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true" app:contentScrim="@color/colorPrimary" app:layout_scrollFlags="scroll|exitUntilCollapsed" app:expandedTitleMargin="20dp" &gt; &lt;ImageView android:layout_width="match_parent" android:layout_height="match_parent" android:fitsSystemWindows="true" android:scaleType="centerCrop" android:src="@mipmap/a14" app:layout_collapseMode="parallax" app:layout_collapseParallaxMultiplier="0.7" /&gt; &lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="50dp" app:layout_collapseMode="pin" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" &gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" app:layout_behavior="@string/appbar_scrolling_view_behavior"&gt; &lt;android.support.design.widget.TabLayout android:id="@+id/sliding_tabs" android:layout_width="match_parent" android:layout_height="wrap_content" app:tabGravity="fill" app:tabIndicatorColor="@color/colorPrimary" app:tabSelectedTextColor="@color/colorAccent" app:tabMode="fixed" /&gt; &lt;android.support.v4.view.ViewPager android:id="@+id/viewpager" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; &lt;/LinearLayout&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 在上面的gif中我们看到的，如果要给ToolBar的返回箭头改颜色的话，直接在AppBarLayout中把theme改掉就好了。 如果要改页面收缩之后的ToolBar背景色，直接在CollapsingToolbarLayout中把app:contentScrim中颜色改成自己想要的就好。 下面的TabLayout选择，如果你想改文字颜色和下划线的颜色，直接把TabLayout中的app:tabIndicatorColor=&quot;@color/colorPrimary&quot; app:tabSelectedTextColor=&quot;@color/colorAccent&quot; 里面的颜色改成自己的就好。 app:layout_scrollFlags=”scroll|exitUntilCollapsed”这是两个Flag控制滚动时候CollapsingToolbarLayout的表现。 Scroll，表示向下滚动列表时候，CollapsingToolbarLayout会滚出屏幕并且消失,想滚动必须设置这个；exitUntilCollapsed，表示这个layout会一直滚动离开屏幕范围，直到它收缩成它的最小高度。enterAlwaysCollapsed - 当你的View已经设置minHeight属性又使用此标志时，你的View只能以最小高度进入，只有当滚动视图到达顶部时才扩大到完整高度。 app:layout_collapseMode=”parallax”设置视差模式。给你想要给用户造成时差效果，给控件加上这个就好。parallax，表示滚动过程中,会一直保持可见区域在正中间；pin，表示不会被滚出屏幕范围。也可以设置视差的系数 app:layout_collapseParallaxMultiplier=”0.7”，设置时差滚动因子，介于 0.0-1.0之间 1234app:expandedTitleMarginapp:expandedTitleMarginBottomapp:expandedTitleMarginEndapp:expandedTitleMarginStart 设置展开状态标题文字的位置 在你要实现上推布局效果的地方加上这句，必须要有，app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; 下面来看一下Java代码中又有哪些好玩的东西。想要显示ToolBar，并让他起作用，就要这样12345678910Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); setSupportActionBar(toolbar); getSupportActionBar().setDisplayHomeAsUpEnabled(true); //添加返回事件 toolbar.setNavigationOnClickListener(new View.OnClickListener() &amp;#123; @Override public void onClick(View view) &amp;#123; onBackPressed(); &amp;#125; &amp;#125;); 这里千万不要把显示的文字加在了ToolBar上面，实际上是加在CollapsingToolbarLayout上面的，下面看一下。 123456 CollapsingToolbarLayout collapsingToolbar = (CollapsingToolbarLayout) findViewById(R.id.collapsing_toolbar); //设置收缩后显示文字颜色collapsingToolbar.setCollapsedTitleTextColor(Color.WHITE);//设置展开时文字的颜色collapsingToolbar.setExpandedTitleColor(Color.BLUE);collapsingToolbar.setTitle("Show Title"); 下面的TabLayout结合ViewPager应该就很简单了123456 TabLayout tabLayout = (TabLayout) findViewById(R.id.sliding_tabs); //设置每个Tab的显示文字tabLayout.addTab(tabLayout.newTab().setText("内容简介"));tabLayout.addTab(tabLayout.newTab().setText("作者简介"));tabLayout.addTab(tabLayout.newTab().setText("目录"));tabLayout.setupWithViewPager(mViewPager); TabLayout上面的文字大小，位置，都可以在xml里面设置的。 配合Viewpager使用就要加上tabLayout.setupWithViewPager(mViewPager)这句话。 如果有啥不对的地方，希望大家在下面指出，一起学习。晚安！ 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android UI</tag>
        <tag>MaterDesign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用TextInputLayout打造友好的Login页面]]></title>
    <url>%2F2016%2F01%2F07%2FPerfectLoginActivity%2F</url>
    <content type="text"><![CDATA[看下面的gif是不是感觉比一般的登陆页面要人性化的多啊，App除了数据是活的，界面在我们的手中也要动起来，今天一起来实现一个这样的友好的Login界面。 上面的两个实际上就是我们平时用的EditText，不一样的是我们给EditText又穿了一件花衣裳，他才会变成这样android.support.design.widget.TextInputLayout写到这里你有可能知道了，想用这个你要在你的gradle中引入compile &#39;com.android.support:design:23.1.1&#39;。就好了来看布局代码 123456789101112&lt;android.support.design.widget.TextInputLayout android:id="@+id/emailView" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;EditText android:id="@+id/emailEt" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="UserName" android:inputType="textEmailAddress" /&gt;&lt;/android.support.design.widget.TextInputLayout&gt; 就这么简单，文章都在java代码，我们来实现它。 12345678910111213141516171819202122232425TextInputLayout tl_email = (TextInputLayout) findViewById(R.id.emailView);tl_username.setHint("请输入正确的邮箱地址");//点击登录按钮findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() &amp;#123; @Override public void onClick(View v) &amp;#123; String email = tl_username.getEditText().getText().toString().trim(); //正则匹配邮箱地址 if (!validateEmail(email)) &amp;#123; //友好的错误提示 tl_username.setError("The emailAddress error"); &amp;#125;else &amp;#123; //将错误提示关掉 tl_username.setErrorEnabled(false); //执行登录操作 doLogin(); &amp;#125; &amp;#125; &amp;#125;); public void doLogin()&amp;#123; //下方提示登录成功，第一个参数为父布局就好 Snackbar.make(parentView, "Login Sucess", Snackbar.LENGTH_SHORT).setAction("login Sucess", null).show(); &amp;#125; 你可以试一试 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AndroidUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android猿猿们的福利]]></title>
    <url>%2F2015%2F12%2F26%2FOutstandingBooks%2F</url>
    <content type="text"><![CDATA[可能大多数的人都用的惯Google，但是当没有网络的时候，Google也给我们调了一个皮，当你不经意间按下Space键，奇迹的事情发生了，嘿嘿，无聊吧！ 年末了，下面分享一下今年我收藏的书吧。 &lt; stream /&gt;&lt; figure https://img3.doubanio.com/lpic/s27243455.jpg Java编程思想 /&gt;&lt; endstream /&gt;有一定的java基础，学好android事半功倍，java不好的android程序员不是好工程师。所以这本java圣经推荐大家一看。 &lt; stream /&gt;&lt; figure https://img3.doubanio.com/lpic/s28351121.jpg 第一行代码 /&gt;&lt; endstream /&gt;郭霖大大的这本《第一行代码》，乃android入门必备，android圣经级的，时不时的翻一翻，会有意想不到的收获。&lt; stream /&gt;&lt; figure https://img3.doubanio.com/lpic/s28283342.jpg Android群英传 /&gt;&lt; endstream /&gt;如果你想在android界自定义View有一席之地，“医生”的这本《群英传》非你莫属。 &lt; stream /&gt;&lt; figure https://img3.doubanio.com/lpic/s28283341.jpg Android开发艺术探索 /&gt;&lt; endstream /&gt;如果你不想在android界平庸，那么“主席”的这本的《艺术探索》，是祝你走向人生的巅峰，赢取白富美的必经之路。 &lt; stream /&gt;&lt; figure https://img3.doubanio.com/lpic/s28320163.jpg Android 源码设计模式解析与实战 /&gt;&lt; endstream /&gt;如果你在android界有啥深入的疑惑，那么SM哥的这本《源码设计模式》你有必要看看了。 &lt; stream /&gt;&lt; figure https://img3.doubanio.com/lpic/s28333166.jpg App研发录：架构设计、Crash分析和竞品技术分析 /&gt;&lt; endstream /&gt;一些平时看起来不起眼的小地方，却被作者写的如此“惟妙惟肖”。 &lt; stream /&gt;&lt; figure https://img3.doubanio.com/lpic/s4157180.jpg 重构 /&gt;&lt; endstream /&gt;如果你对你自己或者别人的代码有啥意见，但是又不敢轻易的去乱动，那么这本《重构》，你要时刻拜读了。 &lt; stream /&gt;&lt; figure https://img1.doubanio.com/lpic/s6263257.jpg 研磨设计模式 /&gt;&lt; endstream /&gt; 2016年刚刚入手的几本书。 &lt; stream /&gt;&lt; figure https://img3.doubanio.com/lpic/s27283822.jpg 图解HTTP /&gt;&lt; endstream /&gt; &lt; stream /&gt;&lt; figure https://img1.doubanio.com/lpic/s27653128.jpg 数学之美 /&gt;&lt; endstream /&gt; &lt; stream /&gt;&lt; figure https://img3.doubanio.com/lpic/s28508155.jpg Android开发进阶_从小公到专家 /&gt;&lt; endstream /&gt; &lt; stream /&gt;&lt; figure https://img1.doubanio.com/lpic/s26676928.jpg 图解TCP/IP /&gt;&lt; endstream /&gt; &lt; stream /&gt;&lt; figure https://img1.doubanio.com/lpic/s27259607.jpg Android开发必知的50个诀窍 /&gt;&lt; endstream /&gt;还没怎么看，但都是很赞的书哦！！ 下面推荐几本最开始看的非技术的书籍，也是兴致勃勃的把它一点点的读完的几本书 &lt; stream /&gt;&lt; figure https://img3.doubanio.com/lpic/s28409836.jpg MacTalk人生元编程 /&gt;&lt; endstream /&gt;池大大的macTalk，也正是看完这本书，才有了我的第一台Mac，不知道你们有没有看，看完有没有冲动，反正我感觉很神奇。 &lt; stream /&gt;&lt; figure https://img3.doubanio.com/lpic/s27932441.jpg 浪潮之巅（第2版）（套装上下册） /&gt;&lt; endstream /&gt;吴军大大《浪潮之巅》《数学之美》《硅谷之谜》，《大学之路》，《文明之光》，套书系列，有幸在年初的时候把浪潮看完了，完美的IT历史教科书。 今年业界最良心的Android开发书籍，基本都在上面了，各位小伙伴各取所需，一定有你需要的地方，把他们请回家，不是让他们睡大觉的，实践是检验真理的唯一标准，一定要看，（虽然我还看的不多😄，2016的计划） 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android开发必备书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio快速生成常用模板]]></title>
    <url>%2F2015%2F12%2F19%2FAndroidStudioTemp%2F</url>
    <content type="text"><![CDATA[从刚开始用AS的时候，还有一丝的Eclipse的味道，但是有一些在Ec上面很方便的东西，在AS上面却一无所措了，比如之前在Ec上面的syso输出的便是System.out.println();然而在AS上面他却没有这么干，而是用sout来输出，今天就带着这个疑惑，这个东西我们从那可以找到并修改成我们熟知的那？ 当你知道了就很简单了，打开AS，打开设置页面，找到Editor，下面的Live Templates 你想知道的全在这里面，图中我选中的就是我们经常用到的Toast，我把他改成了tst，我们只要在代码中输入tst，即可出来下面的Template text中生成的一句代码，还有我们经常用的findViewById等等，你可以一个个点开，看看他的描述，然后加上自己的熟悉的快捷短语即可。 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>AndroidStudio</category>
      </categories>
      <tags>
        <tag>AndroidStudio小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断App是否在模拟器上运行]]></title>
    <url>%2F2015%2F12%2F16%2FisRunningInEmualtor%2F</url>
    <content type="text"><![CDATA[我们之前看友盟的统计，发现有一些bug，都是在模拟器类型报的错，我们干脆就不让在模拟器安装了，下面我们来看一下。 首先我们来看一下Runtime这个类，他是一个与JVM运行时环境有关的类，这个类是Singleton的。1Allows Java applications to interface with the environment in which they are running. Applications can not create an instance of this class, but they can get a singleton instance by invoking getRuntime(). 上面是在developer上面摘的Runtime. 这里面有这么几个重要方法，exec(),gc(),getRuntime(),maxMemory(),exit()等等，我们今天主要看exec方法,exec有六个重载。也就是我们今天要看的。 如果想与调用的程序进行交互，那么就要使用该方法的返回对象Process了，通过Process的getInputStream()，getOutputStream()和getErrorStream()方法可以得到输入输出流，然后通过InputStream可以得到程序对控制台的输出信息，通过OutputStream可以给程序输入指令,这样就达到了程序的交换功能。 先来上代码，光说理论就没意思了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 判断是否在模拟器上运行 * * @return */ public static boolean isRunningInEmualtor() &amp;#123; boolean quemuKernel = false; Process process = null; DataOutputStream os = null; BufferedReader in = null; try &amp;#123; process = Runtime.getRuntime().exec(".\\a.exe"); os = new DataOutputStream(process.getOutputStream()); in = new BufferedReader(new InputStreamReader( process.getInputStream(), "GBK")); os.writeBytes("exit\n"); os.flush(); process.waitFor(); quemuKernel = (Integer.parseInt(in.readLine()) == 1); &amp;#125; catch (Exception e) &amp;#123; quemuKernel = false; &amp;#125; finally &amp;#123; if (process != null) &amp;#123; process.destroy(); process = null; &amp;#125; if (in != null) &amp;#123; try &amp;#123; in.close(); &amp;#125; catch (IOException e) &amp;#123; e.printStackTrace(); &amp;#125; in = null; &amp;#125; if (os != null) &amp;#123; try &amp;#123; os.close(); os = null; &amp;#125; catch (Exception e) &amp;#123; e.printStackTrace(); &amp;#125; &amp;#125; &amp;#125; return quemuKernel; &amp;#125; 第一行的“.\a.exe”是要执行的程序名，Runtime.getRuntime()返回当前应用程序的Runtime对象，该对象的exec()方法指示Java虚拟机创建一个子进程执行指定的可执行程序，并返回与该子进程对应的Process对象实例。通过Process可以控制该子进程的执行或获取该子进程的信息。 上面这个代码直接拿着用就好，然后把执行的程序名换成自己的就好。123456if (Utils.isRunningInEmualtor()) &amp;#123; Toast.makeText(IgniteApplication.getInstance(), "我们不支持在模拟器上运行哦", Toast.LENGTH_SHORT).show(); finish(); return; &amp;#125; 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android奇技淫巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多渠道打包那些事]]></title>
    <url>%2F2015%2F12%2F03%2FAndroidMultiChannelBuild%2F</url>
    <content type="text"><![CDATA[最近在AndroidStudio上进行多渠道打包，虽然渠道包不多，但是手动打包，一向很懒的程序员往往是不会干的，好的工具都是懒人创造出来的。之前就看过stormzhang关于多渠道打包的那些事，但是每个公司的渠道不一样，有各种各样的渠道号，今天就被两种给搞的一直编译不过。原来是这样.如果你的渠道号中有360，91这一类，那么你的productFlavors里面的配置就要这样，渠道前面加_ _360 &lt;&amp;#125; 如果你的渠道号中有这么一类，abc.bug,那么你就要这样写 &quot;abc.bug &lt;&amp;#125;&quot; 还有就是刚开始的时候打包成功，但是上传到各大AppMarket的时候，提示此App未签名。有一个地方一定要写上，stormzhang上面也有，但是这里重点提醒一下 signingConfig signingConfigs.release 就是这句一定要加上，不然虽然包能打出来，但是是无效的。 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>AndroidStudio</category>
      </categories>
      <tags>
        <tag>多渠道打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtomPlugins]]></title>
    <url>%2F2015%2F12%2F01%2FAtomPlugins%2F</url>
    <content type="text"><![CDATA[想必这两幅图大家一定很熟悉吧，最近在朋友圈，微博上面他可是没少出现，一个Atom编辑器的插件，很6，今天装了一下，自我感觉不是我的菜。。。平时玩玩还可以。。很简单，跟我一起来 如果你的电脑上面没有Atom这款编辑器的，到Atom官网自行下载，选择适合自己的版本下载即可。这里我只介绍Mac上面的安装，其他出问题概不负责，哈哈。Atom安装完成之后，我们就要安装插件了，安装之前首先你电脑上面要安装git，mac就不说了，你懂的，windows上面没有的小伙伴可以看这里git安装教程。下面开始安装插件，找到.atom的文件夹，这是一个隐藏文件，你可以用命令行显示所有隐藏文件，亦或直接终端定位到这个文件夹，然后执行1234git clone https://github.com/JoelBesada/activate-power-mode.gitcd activate-power-modeapm insatllapm ls #检测是否成功 这样重启我们的Atom，然后control+aption+o打开这个插件的开关，如果点玩之后发现右上角出现错误，而且没有任何效果1234567At Cannot find module &apos;lodash.throttle&apos;Error: Cannot find module &apos;lodash.throttle&apos; at Module._resolveFilename (module.js:336:15) at Function.Module._resolveFilename (F:\atom\Atom Beta\resources\app.asar\src\module-cache.js:383:52) at Function.Module._load (module.js:286:25) at Module.require (module.js:365:17) ...... 是这样的说明你的lodash.throttle依赖没有安装，我刚开始的时候就是出现这个问题。直接进到这个package目录，执行下列命令npm install lodash.throttle 即可。话说这个Atom很占内存啊，之前一直用的Sublimtext，之后可能还会继续用，但是这里还是要感谢这位牛逼的插件作者，写个代码也得写得这么轰动。。。要是As上面支持就好了。。。（后续应该会有吧）哈哈]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Atom插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的View冲突事件处理]]></title>
    <url>%2F2015%2F11%2F30%2Fandroid-view-listen-event%2F</url>
    <content type="text"><![CDATA[前几天我们App上面有这么一个需求，就是在我们发照片的地方会贴上标签，但是这个标签可以点击删除，可以长按翻转，可以移动地方，那就会涉及到事件的冲突处理，这地方会有onClick,onLongClick,onTouch,总的来说，所有的事件都由如下三个部分作为基础： 按下(ACTION_DOWN) 移动(ACTION_MOVE) 抬起(ACTION_UP) 下面我们先从事件的实现开始来看看，最后我们一起来实现需求。所有的操作事件首先会执行按下操作，之后的所有的操作都是以按下操作作为前提，当按下完成后，接下来可能是移动然后抬起，或者按下之后直接抬起，这一系列都是可以进行控制的。 我们知道，这些所有的触摸操作都是发生在触摸屏上，而在屏幕上与我们交互的是各种各样的试图组件View，所有的视图都继承于View，另外通过各种布局组件（ViewGroup）来对View进行布局，ViewGroup也继承于View。那么View和ViewGroup中主要有哪些方法来对这些事件进行响应哪？查看View和ViewGroup源码可知：View.java12public boolean dispatchTouchEvent(MotionEventevent)public boolean onTouchEvent(MotionEvent event) ViewGroup.java123public boolean dispatchTouchEvent(MotionEvent event)public boolean onTouchEvent(MotionEvent event) public boolean onInterceptTouchEvent(MotionEvent event) 通过比对上面这几个方法可以看出，这里面有两个方法是公有的，dispatchTouchEvent和onTouchEvent，那么ViewGroup的第三个方法是干啥的那，不要着急，慢慢往下看。还有一个共同的地方就是他们的返回值竟然都是boolean类型，为什么会都是boolean类型，想想我们写这个博文的初衷，“事件传递”，传递嘛，就是一个接一个，那总要有结束的时候啊，这个boolean就是控制这个的，到了某一个点后是否继续往下传递，这个返回值很重要。所有的事件都是从开始传递到最后事件的消费，那么这个返回值就决定了是否继续传递，还是被拦截，或者消费了。介绍完了返回值，接下来我们来看看这些方法的参数，都接收一个MotionEvent参数，这个参数继承于InputEvent，作用就是标记各种动作事件，刚开始说到的ACTION_DOWN，ACTION_MOVE，ACTION_UP，都是MotionEvent中定义的常量，我们就是通过这个常量来知道用户的具体操作事件。现在，我们对返回值和参数都有一定的概念了，下面来看一下这三个方法分别在什么时候处理事件。 dispatchTouchEvent()dispatch派遣，分发的意思，很明显这个方法就是用于事件的分发，Android中所有事件都必须经过这个方法来处理，决定是自身消费当前事件，还是继续分发给子View处理。返回true表示不继续分发，事件没有得到消费。反之，继续分发，如果是ViewGroup则分发给onInterceptTouchEvent进行判断是否拦截该事件。 onTouchEvent()主要用于事件的处理，返回true，则消费此次事件，返回false，则不处理，交给子View处理。 onInterceptTouchEvent()这是ViewGroup中独有的方法，作用就是事件的拦截，返回true，拦截当前事件，不继续分发，交给自身的onTouchEvent处理。返回false，不拦截，继续传递。为什么View没有这个方法，因为ViewGroup中可能还会有子View，而在Android中View是不可能再有View的（iOS是可以的）。 实践这三个方法的实例的代码这里就不贴了，自己写一个demo，然后重写以上方法，各种手势，打Log。看下图，一般都是按照这个流程的 画的有点丑，在sketch上面自己草草画的。下面我们来看看多布局事件传递多布局，也就是ViewGroup，这里要比上面多写一个onInterceptTouchEvent方法，ViewGroup中独有的，作用就是控制事件是否需要拦截。这里就出来一个问题，一个事件是先传递到View，还是ViewGroup呐？最后直接上答案，Android中事件的传递，是从ViewGroup传递到View的，这个也不是很难理解。下面我们来看看如何实现刚刚从一开始说的那个怎么实现吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586private ClickEvent mEvent; private long pressStartTime; private boolean isMove = false; private Handler outerHandler; /** * 当前触摸点相对于屏幕的坐标 */ private int mCurrentInScreenX; private int mCurrentInScreenY; /** * 触摸点按下时的相对于屏幕的坐标 */ int prevRawX, prevRawY; private static final long LONG_PRESS_TIME = 500; /** * 长按线程 */ private LongPressedThread mLongPressedThread; this.setOnTouchListener(new OnTouchListener() ｛ float prevX, prevY; @Override public boolean onTouch(final View v, final MotionEvent event) &lt; //获取相对屏幕的坐标，即以屏幕左上角为原点 mCurrentInScreenX = (int) event.getRawX(); mCurrentInScreenY = (int) event.getRawY(); switch (event.getAction() &amp; MotionEvent.ACTION_MASK) &lt; case MotionEvent.ACTION_MOVE: &lt; //取消注册的长按事件 outerHandler.removeCallbacks(mLongPressedThread); //处理移动逻辑 return true; &amp;#125; case MotionEvent.ACTION_UP: &lt; if (!isMove()) &lt; if (Calendar.getInstance().getTimeInMillis() - pressStartTime &lt;= LONG_PRESS_TIME) &lt; outerHandler.removeCallbacks(mLongPressedThread); if (mEvent != null) &lt; //点击事件 mEvent.onClick(); &amp;#125; &amp;#125; &amp;#125; return true; &amp;#125; case MotionEvent.ACTION_DOWN: &lt; pressStartTime = System.currentTimeMillis(); prevRawX = (int) event.getRawX(); prevRawY = (int) event.getRawY(); mLongPressedThread = new LongPressedThread(); outerHandler.postDelayed(mLongPressedThread, LONG_PRESS_TIME); &amp;#125; &amp;#125; return true; &amp;#125; &amp;#125;); public class LongPressedThread implements Runnable &lt; @Override public void run() &lt; //长按事件 mEvent.onLongClick(); &amp;#125; &amp;#125; public void setClickEvent(ClickEvent event) &lt; this.mEvent = event; &amp;#125; private boolean isMove() &lt; if (Math.abs(prevRawX - mCurrentInScreenX) &lt;= 5 &amp;&amp; Math.abs(prevRawY - mCurrentInScreenY) &lt;= 5) &lt; isMove = false; &amp;#125; else &lt; isMove = true; &amp;#125; return isMove; &amp;#125; public interface ClickEvent &lt; void onClick(); void onLongClick(); &amp;#125; 首先我们添加了onTouchListener事件，重写onTouch事件，上面已经说过，任何事件都是从Down开始的，源码中已经告诉我们，如果没有down，后续的所有事件将毫无意义。上面我们在Down中纪录了按下的时间，开启一个线程然后延迟500ms（长按触发的时间）后执行，然后再UP的时候我判断如果按住的时间没有超过了500ms那么代码长按事件没有触发，然后执行点击事件的逻辑，同时删除掉Handler队列中的处理长按事件的线程，如果执行了Move事件也需要删除Handler队列里面的长按处理线程。我们只要在想用的地方这样就好了 1234567891011View.setClickEvent(new CustomView.ClickEvent() &lt; @Override public void onClick() &lt; //处理你的点击逻辑 &amp;#125; @Override public void onLongClick() &lt; //处理你的长按逻辑 &amp;#125;&amp;#125;); 综上所述我上高中的时候，我数学老师最爱说的一句话就是综上所述，直接出答案。 Android 中的事件传递展现的是一种层级关系，从上往下，从ViewGroup到View。 事件传递有三个重要的方法，dispatchTouchEvent、onTouchEvent、onInterceptTouchEvent，前两个是View和ViewGroup共有的，最后一个是ViewGroup特有的。他们分别负责的事情就是，事件的分发，事件的处理，事件的拦截。 onTouch事件优先于onClick执行，onTouchEvent要后于dispatchTouchEvent方法调用。因为onTouch在事件分发完在dispatchTouchEvent中调用，而onClick在事件处理方法onTouchEvent中调用。 夜已经深了，今天也比较累了，可能就是让这个搞得吧，但是最终还是solve了，大家晚安。GoodNight。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android事件处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序员的黄金搭档]]></title>
    <url>%2F2015%2F11%2F26%2FHero%2F</url>
    <content type="text"><![CDATA[一个好的工作环境不只是公司给我们提供，也需要我们自己配置，工欲善其事，必先利其器。为自己搭建一个令自己开开森森的工作台，岂不美哉美哉。 题图是我最近拍的 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于App中再按一次退出实现方式]]></title>
    <url>%2F2015%2F11%2F21%2FAppExit%2F</url>
    <content type="text"><![CDATA[想必大家都见过，大多数的App都有这么一种情况，就是当我们在App上进行如何操作，在最后快要退出的时候，往往要连按两次Back键，第一次的时候会有提示“再按一次退出”等提示语，在提示还没消失的时候再按一次，应用真正退出。下面我们就来看看如何简单实现这一种，第一种是我们的常规做法，第二种保准会让你爱不释手。 12345678910private long exitTime = 0; @Override public void onBackPressed() &amp;#123; if ((System.currentTimeMillis() - exitTime) &gt; 2000) &amp;#123; Toast.makeText(this,R.string.press_again_exit_app,Toast.LENGTH_SHORT).show(); exitTime = System.currentTimeMillis(); &amp;#125; else &amp;#123; finish(); &amp;#125; &amp;#125; 我们在这里重写onBackPresswd(),判断时间戳，想必大家都是这么实现的，这里介绍一个简单的Method。12345678910111213141516 public Toast toast; @Override protected void onCreate(Bundle savedInstanceState) &amp;#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); toast = Toast.makeText(this, "再按一次退出", Toast.LENGTH_LONG); &amp;#125; @Override public void onBackPressed() &amp;#123; if(null == toast.getView.getParent())&amp;#123; toast.show(); &amp;#125;else&amp;#123; System.exit(0); &amp;#125;｝ 当我们的toast显示不消失，那么我们获取到的toast.getView.getParent()始终不为空，在我们在toast没消失的时候再点击一次Back，那么整个应用退出。是不是很简单啊。 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习网站整理]]></title>
    <url>%2F2015%2F11%2F19%2FStudyAndroidWebsite%2F</url>
    <content type="text"><![CDATA[今天晚上把之前收集的一些有用的csdn，blogs，github分享给大家，这里面不止有android的东西，还有iOS的东西，前端，后台…这就是我们android开发人员的精神食粮，每天吮吸那么一点点。。。。 Android 别人整理的 Android 学习资源网站 任玉刚 张兴业 陈启超 Google学习demo Android学习之旅 码农明明桑 Android 郭霖 鸿洋 MrSimple何鸿辉 AigeStudio关爱民 Aige个人小站 Android_Tutor Android流媒体技术 林炳文 老罗，罗升阳 邓凡平 Trinea Android问题集锦 AndroidStudio问题集锦 亓斌 AndroidUI优化 Will Java编程思想 stormzhang sunzn’Blog Android实战小项目 Android小片段 Android学习系列 夏安明 徐宜生 Android自定义View 王鹏Android 张涛 胡凯 Java高级 Stay 鸟窝 Android 开源项目源码解析 Android源码设计模式分析项目 Android 开源项目分类汇总 巫小刚 赵凯强 张明云 Android魔法学院 掉线的Android android-cn 小米开源社区 Android开发博文 马天宇Android Android笔记 Android技术总结 工匠若水 工匠若水2 nomasp柯于旺 每天一道算法 Android系列博文 SimpleBloger 猫头鹰技术博客 AndroidStudio教程 gitBook 晓峰 Android程序人生 Android填坑手册 Android话题 Android开发技术周报 Codekk源码 AndroidStudio专栏 天真无邪Android技术 Android开源项目 git教程 markzhai-魔都大帅 技术小黑屋 小钢Android 稀有猿诉 唐韧 廖祜秋 一叶飘舟 谷哥的小弟 QQ空间终端开发-Android相机开发那些坑&amp;version=11020201&amp;pass_ticket=nGtC65w6xV2ek%2FFuwmH4lhHBfWD3CJETV1gyVmBVaIc%3D) Android安全中文站 RX Java中文版 KotlinGitBook中文版 查看Android源码 JakeWhartonGithub 给Android开发者的RxJava详解 大头鬼Blog Google开源项目 如何高效学习动画－知乎 Android官方培训课程中文版 Kotlin for android developers》中文版 Android开发经验谈 Android 开发规范与应用 阳春面blog 好的Android开发习惯 Android－gms AndroidStudio系列文章 GDG Android优质文章－开发技术前线 RxJava资料 吴小龙 第三方库的使用心得 AndroidSDK源码分析 腾讯Bugly专栏 胡家威 2016GoogleIO视频 玩 Android 技术笔记 JacksBlog 高产 Piasy 不翻墙的小伙伴可以访问的AndroidDeveloper 小创的 Android 单元测试 Gityuan 孤独狂饮 Diycode 每日精选 各种 UI 特效 Android 学习资料整理 Android 学习笔记大全 韩海龙 Android 郑晓勇一些优化方面实践 田维术一些插件化方面实践 区长csdn iOS Why’s BlogSwift iOS开发集锦 王巍喵神 YYKitiOS 吕文瀚iOS 唐巧 破船之家iOS iOS博客 objc中国 ios_swift开发资源整理 Sunny iOS MJiOS Cracking the coding interview iOS开源库 iOS技术博文 Swift干货 孙启超swift iOS博文 从今天开始学习swift Swift 语言指南 swift小应用 swift社区 iOS技术团队 iOS开发60分钟入门 移动开发点点滴滴 GitHub排名前50的Objective-C开发者 让不懂编程的人爱上iOS iOS开发网站 南峰子iOS 有态度的iOScoder iOS开源项目 swift微信 kevinzhow-送给女朋友的iOS视频 iOS学习资料整理 iOS，Mac开源框架 中文 iOS/Mac 开发博客列表 关注被忽略的OC，Swift和Cocoa特性 iOS架构方面 iOS动画小王子 30 Days of Swift iOS 逆向相关 swift-evolution 笨猫学编程专栏 其他 冯大辉个人Blog 开发技术前线 每天一个Linux命令 Baidu免费API App测试 菜鸟各种教程 美团点评技术团队 Android开发技术周报 泡在网上的日子 阮一峰 廖雪峰 如何用好Google搜索引擎 objc中国 走心的Swift翻译组 As主题配置 刷算法 微信读书团队 diyicode社区 看雪安全论坛 江青青的技术专栏，专注移动开发 大前端 优雅的使用你的SublimeText3 构建 F8 React-Native学习指南 30-days-of-react-native 摄图网 VIM 教程 一个开源镜像站点, xCode,SDK,Gradle 更新站点 Bugly 社区 我们可以自己玩的一些 API 一大波 gitbook 书籍 后续会继续添加，继续维护 版权声明： 除非注明，本博文章均为原创，转载请以链接形式标明本文地址。]]></content>
      <categories>
        <category>学习网站整理</category>
      </categories>
      <tags>
        <tag>学习资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio中的javaMaxHeapSize和multiDexEnabled问题]]></title>
    <url>%2F2015%2F11%2F19%2FAndroidStudioCompilerError%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;来公司已经四个月了，来公司之前，公司的代码是在eclipse上面开发的，但是我个人完全已经爱上了AndroidStudio了，决定把公司的代码转移阵地，和leader几番商量之后，来到了Studio，由于项目一点点变大，也要跟上时代App的步伐，所以这一步肯定是没错的，As的好处这里就不多说了，但是好处的同时也会带来苦恼，一些问题基本见都没见过，自己一点点的来就是唯一的解决办法。下面说两个我们遇到的问题 &nbsp;&nbsp;&nbsp;&nbsp;当我们把项目转移到AS之后出现了下面两个问题，大家一起看看。第一个错误就是方法数超过65536，很常见。如果要在之前在Eclipse中要分包啥的，反正很麻烦，现在有了AS大法好，下面说；第二个错误就是一个OOM，但不是我们平时见到的，是一个关于java层的OOM，error中有一个关于4g的错误标识，下面说。//当时忘了截图。。。。 这两个问题不知大家见过没见过，但是当我看见她的时候我蒙了，因为我在clean，build代码的是是successful的，run完之后竟然给我来了这么一出，但是我看到了其中的65536，DexIndexOverflowException,OOM,这么熟悉的几个bug代名词，让我浮想联翩，中间的过程就不说了，直接来处理方法，以及结果吧。 &nbsp;&nbsp;&nbsp;&nbsp;对于上图中第一个error哪，处理方法是这样的，只要在app的build.gradle中加上下面这几句1234567defaultConfig &amp;#123; multiDexEnabled true &amp;#125; dependencies &amp;#123; compile 'com.android.support:multidex:1.0.0'&amp;#125; 最后还要让你的自定义的Application类继承MultiDexApplication，就可以了。如果不想继承的话也可以，只要在你的application类里面重写这个方法就好了123456protected void attachBaseContext(Context base) &amp;#123; super.attachBaseContext(base); MultiDex.install(this);&amp;#125; 第一个我们已经fix掉了，下面我们来解决第二个问题，就是OOM，但这个OOM和我们平时见到的OOM不一样，这个是java层报的OOM，那就是运行时内存不够了呗，这里在build.gradle里面同样加上一句话也管用。 123dexOptions &amp;#123; javaMaxHeapSize &quot;4g&quot; &amp;#125; 重新编译，运行，OK，可以了，Android之路，我们是在平坦的道路上曲折前行啊，这句话配上许岑老师就帅了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>AndroidStudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乔迁之喜]]></title>
    <url>%2F2015%2F11%2F17%2FFirst%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;首发有福利哦。。。。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;搭建属于自己的个人Blog，心生已久，作为一个程序员就应该有一个属于自己空间的小地方，想写什么写什么，想吐槽什么吐槽什么，做一个快快乐乐的猿猴。。。。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里我可能不会说博客的搭建过程，因为你去Google一把，前两篇就能保证教会你，我就是亲身体验用户，搭建出了一个在我眼里看着还可以的BlogZone，我会陆陆续续的把我csdn上的一些不成熟的博文移到这里面来，写博客确实是一件很费时间，费精力的事情，因为你要准备，你要实践。但是，当你的博客hexo g -d 的时候，你的成就感油然心生，你看到了成果，一篇博客的诞生会让你高兴半天，之前在csdn，偶尔会写一篇，但是现在不一样了，现在这个东西是我自己的记事本，我会时不时的纪录下我在Android路上踩到的坑，以及一些好玩的小技巧。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;希望通过这个机会能够认识到更多Android小伙伴，一起学习，一起交流]]></content>
      <categories>
        <category>随记</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
